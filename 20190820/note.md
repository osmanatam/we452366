## ES2015

### 作用域变量
> 作用域就是一个变量的作用范围。也就是你声明一个变量以后,这个变量可以在什么场合下使用 以前的JavaScript只有全局作用域，还有一个函数作用域

#### var的问题
- var没有块级作用域，定义后在当前闭包中都可以访问，如果变量名重复，就会覆盖前面定义的变量，并且也有可能被其他人更改。
- var在for循环标记变量共享，一般在循环中使用的i会被共享，其本质上也是由于没有块级作用域造成的

#### 块级作用域
> 在用var定义变量的时候，变量是通过闭包进行隔离的，现在用了let，不仅仅可以通过闭包隔离，还增加了一些块级作用域隔离。 块级作用用一组大括号定义一个块,使用 let 定义的变量在大括号的外面是访问不到的

- 实现块级作用域
- 不会污染全局对象
- for循环中也可以使用i
- 重复定义会报错
- 不存在变量的预解释
- 闭包的新写法

### 常量
> 使用const我们可以去声明一个常量，常量一旦赋值就不能再修改了

- 常量不能重新赋值
- 变量值可改变
- 不同的块级作用域可以多次定义

### 解构
> 解构意思就是分解一个东西的结构,可以用一种类似数组的方式定义N个变量，可以将一个数组中的值按照规则赋值过去。

- 解析数组
- 嵌套赋值
- 省略赋值
- 解构对象
- 默认值

### 字符串
> 模板字符串用反引号(数字1左边的那个键)包含，其中的变量用${}括起来

- includes()：返回布尔值，表示是否找到了参数字符串。
- startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。
- endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部
- repeat()：repeat方法返回一个新字符串，表示将原字符串重复n次。

### 函数

#### 默认参数
> 可以给定义的函数接收的参数设置默认的值 在执行这个函数的时候，如果不指定函数的参数的值，就会使用参数的这些默认的值

#### 展开操作符
> 把...放在数组前面可以把一个数组进行展开,可以把一个数组直接传入一个函数而不需要使用apply

#### 剩余操作符
> 剩余操作符可以把其余的参数的值都放到一个叫b的数组里面

#### 解构参数

#### 函数的名字
> ECMAScript 6 给函数添加了一个name属性

```
var desc = function descname(){}
console.log(desc.name);
```

#### 箭头函数
> 箭头函数简化了函数的的定义方式，一般以 "=>" 操作符左边为输入的参数，而右边则是进行的操作以及返回的值inputs=>output。箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。 正是因为它没有this，从而避免了this指向的问题。

#### 数组
- from()：将一个数组或者类数组变成数组,会复制一份
- Array.of()：of是为了将一组数值,转换为数组
- copyWithin()：Array.prototype.copyWithin(target, start = 0, end = this.length) 覆盖目标的下标 开始的下标 结束的后一个的下标
- find()：查到对应的元素和索引
- fill()：就是填充数组的意思 会更改原数组 Array.prototype.fill(value, start, end = this.length);
- map()
- reduce()
- filter()
- forEach()

### 对象
> 如果你想在对象里添加跟变量名一样的属性，并且属性的值就是变量表示的值就可以直接在对象里加上这些属性

- Object.is()：对比两个值是否相等
- Object.assign()：把多个对象的属性复制到一个对象中,第一个参数是复制的对象,从第二个参数开始往后,都是复制的源对象
- Object.setPrototypeOf：将一个指定的对象的原型设置为另一个对象或者null
- proto：直接在对象表达式中设置prototype
- super：通过super可以调用prototype上的属性或方法