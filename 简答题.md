# 简答题

## HTML

### Doctype作用？标准模式与兼容模式各有什么区别？
```
> 声明位于HTML文档中的第一行，处于html标签之前，告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。
标准模式的排版和js运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器以防止站点无法工作过。
```

### 介绍一下你对浏览器内核的理解
```
> 主要分成两部分：渲染引擎(layout engine 或 rendering engine)和js引擎

渲染引擎：负责取得网页的内容(HTML、XML、图像等等)、整理讯息(例如加入css等)，以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网格内容的应用程序都需要内核

js引擎：解析和执行javascript来实现网页的动态效果

最开始渲染引擎和js引擎并没有区分很明确，后来js引擎越来越独立
```

### 常见的浏览器内核有哪些？
```
- Trident内核：IE、MaxThon、TT、The World、360、搜狗浏览器等。[又称MSHTML]
- Gecko内核：Netscape6及以上版本、FF、MozillaSuite、SeaMonkey等
- Presto内核：Opera7及以上。[Opera内核原为Presto，现为Blink]
- Webkit内核：Safari、Chrome等。[Chrome的Blink(webkit的分支)]
```

### h5新特性有哪些?
```
- 增强了图形渲染(canvas)
- 影音(video,audio)
- 数据存储(sessionStorage/localStorage)
- 语义化更好的元素，比如article、footer、header、nav、section
- 表单控件，calendar、date、time、email、url、search
- 新的技术，webworker(专用线程)、websocket(全双工通信)、Geolocation地理定位
```

### 如何处理html5新标签的兼容性
```
> IE6/7/8支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式，最好的方式是直接使用成熟的框架，使用最多的是html5shiv框架 <!--[if it IE 9]><script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
```

### 简述一下你对HTML语义化的理解
```
- 用正确的标签做正确的事情
- html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析
- 即使在没有样式css情况下也以一种文档格式显示，并且是容易阅读的
- 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO
- 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解
```

### 请描述一下cookie、sessionStorage和localStorage的区别
```
- 相同点：都存储在客户端
- 不同点：
    - 存储大小：
        - cookie数据大小不能超过4k
        - sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大的多，可以达到5M或更大，就是为了解决cookie存储空间不足而诞生的
    - 有限时间：
        - localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据
        - sessionStorage数据在当前浏览器窗口关闭后自动删除
        - cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
    - 数据域服务器之间的交互方式
        - cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端
        - sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存
```

### iframe有哪些缺点
```
- iframe会阻塞主页面的onload事件
- 搜索引擎的检索程序无法解读这种页面，不利于seo
- iframe和主页面共享连接池，而浏览器对相同域的链接有限制，所以会影响页面的并行加载
> 使用iframe之前需要考虑这些缺点，如果需要使用iframe，最好通过JavaScript动态给iframe添加src属性值
```

### 网页验证码是干嘛的，是为了解决什么安全问题？
```
> 是为了防止一些人使用软件恶意注册、发帖等行为而设的，它的存在是为了确保登录网站的是一个坐在电脑面前的真人，而不是一个自动登录的软件
```

### 如何判断浏览器的userAgent
```
- 如果userAgent中包含MSIE，说明一定是IE浏览器
- 如果userAgent中包含Trident却不包含MSIE，说明一定是IE11浏览器
- 如果userAgent中包含Firefox，说明一定是Firefox浏览器
- 如果userAgent中包含OPR，说明一定是Opera浏览器
- 如果userAgent中包含Edge，说明一定是Edge浏览器
- 如果userAgent中包含Edge，说明一定是Chrome浏览器
- 如果userAgent中包含Edge，说明一定是Edge浏览器
```

### 请简述js的垃圾回收机制
```
垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，
并释放掉它们所指向的内存; 主要为了以防内存泄漏，
(内存泄漏: 当已经不需要某块内存时这块内存还存在着), 

JS有两种变量: 全局变量和在函数中产生的局部变量。
局部变量的生命周期在函数执行过后就结束了，
此时便可将它引用的内存释放(即垃圾回收); 
但全局变量生命周期会持续到浏览器关闭页面。

JS执行环境中的垃圾回收器有两种方式：
标记清除（mark and sweep）、
引用计数(reference counting)。

标记清除:  垃圾收集器给内存中的所有变量都加上标记，
然后去掉环境中的变量以及被环境中的变量引用的变量的标记。
在此之后再被加上的标记的变量即为需要回收的变量，
因为环境中的变量已经无法访问到这些变量。

引用计数(reference counting):  这种方式常常会引起内存泄漏，
低版本的IE使用这种方式。机制就是跟踪一个值的引用次数，
当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，
当这个变量指向其他一个时该值的引用次数便减一。
当该值引用次数为0时就会被回收。
```

### 什么是渐进式渲染（progressive rendering）？
```
> 渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。

在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。

一些举例：

- 图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像。
确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 CSS、脚本和内容，然后可以使- 用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。
- 异步加载 HTML 片段——当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器。更多相关细节可以在这里找到。
```

### viewport是什么？
```
> Viewport ：字面意思为视图窗口，在移动web开发中使用。表示将设备浏览器宽度虚拟成一个特定的值（或计算得出），这样利于移动web站点跨设备显示效果基本一致。移动版的 Safari 浏览器最新引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放，其他手机浏览器也基本支持。

在移动端浏览器当中，存在着两种视口，一种是可见视口（也就是我们说的设备大小），另一种是视窗视口（网页的宽度是多少）。举个例子：如果我们的屏幕是320像素 * 480像素的大小（iPhone4），假设在浏览器中，320像素的屏幕宽度能够展示980像素宽度的内容。那么320像素的宽度就是可见视口的宽度，而能够显示的980像素的宽度就是视窗视口的宽度。

为了显示更多的内容，大多数的浏览器会把自己的视窗视口扩大，简易的理解，就是让原本320像素的屏幕宽度能够容下980像素甚至更宽的内容（将网页等比例缩小）。

- Viewport属性值

    - width 设置layout viewport 的宽度，为一个正整数，或字符串"width-device"
    - initial-scale 设置页面的初始缩放值，为一个数字，可以带小数
    - minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数
    - maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数
    - height 设置layout viewport 的高度，这个属性对我们并不重要，很少使用
    - user-scalable 是否允许用户进行缩放，值为"no"或"yes", no 代表不允许，yes代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。
```

### img中的alt和元素的title属性作用
```
- img的alt属性
如果无法显示图像，浏览器将显示alt指定的内容

- 元素title属性
在鼠标移到元素上时显示title的内容
```

### href和src区别
```
- href
href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系
若在文档中添加href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。

- src
src表示引用资源，替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。
当浏览器解析到src ，会暂停其他资源的下载和处理（图片不会暂停其他资源下载），直到将该资源加载、编译、执行完毕，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。
```

### 行内元素和块级元素有哪些
```
- 行内元素

一个行内元素只占据它对应标签的边框所包含的空间
一般情况下，行内元素只能包含数据和其他行内元素

b, big, i, small, tt
abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var
a, bdo, br, img, map, object, q, script, span, sub, sup
button, input, label, select, textarea

- 块级元素

占据一整行，高度、行高、内边距和外边距都可以改变，可以容纳块级标签和其他行内标签

header,form,ul,ol,table,article,div,hr,aside,figure,canvas,video,audio,footer
```

### label标签有什么作用
```
> label 标签通常是写在表单内，它关联一个控件，使用 label 可以实现点击文字选取对应的控件。

<input type="checkbox" id="test">
<label for="test" >test</label>
```

### HTML5的form如何关闭自动完成功能
```
> 将不想要自动完成的 form 或 input 设置为 autocomplete=off
```

### DOM和BOM有什么区别
```
- DOM：
Document Object Model，文档对象模型

DOM 是为了操作文档出现的 API，document 是其的一个对象

DOM和文档有关，这里的文档指的是网页，也就是html文档。DOM和浏览器无关，他关注的是网页本身的内容。

- BOM：
Browser Object Model，浏览器对象模型

BOM 是为了操作浏览器出现的 API，window 是其的一个对象

window 对象既为 javascript 访问浏览器提供API，同时在 ECMAScript 中充当 Global 对象
```

### 为什么最好把 CSS 的<link>标签放在<head></head>之间？为什么最好把 JS 的<script>标签恰好放在</body>之前，有例外情况吗？
```
- 把<link>放在<head>中

把<link>标签放在<head></head>之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。

- 把<script>标签恰好放在</body>之前

脚本在下载和执行期间会阻止 HTML 解析。把<script>标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。

例外情况是当你的脚本里包含document.write()时。但是现在，document.write()不推荐使用。同时，将<script>标签放在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是，<script>使用defer属性，放在<head>中。
```

### 从前端角度出发, 谈谈做好网站seo需要考虑什么?
```
- 语义化html标签;
- 合理的title, description, keywords;
- 重要的html代码放前面;
- 少用iframe, 搜索引擎不会抓取iframe中的内容
- 图片加上alt
```

## 网络和安全

### 如何实现浏览器多个标签页之间的通信？
```
- cookie+setInterval
- localStorage
- webSocket
- SharedWorker
```

### 一个页面从输入url到页面加载显示完成，发生了什么？
```
1.浏览器通过DNS将url地址解析为ip(如果有缓存直接返回缓存，否则递归解析)
2.通过DNS解析得到了目标服务器的ip地址后，与服务器建立TCP连接。
    - ip协议：选择传输路线，负责找到
    - tcp协议：三次握手，分片，可靠传输，重新发送的机制
3.浏览器通过http协议发送请求(增加http的报文信息)头 体 行
4.服务器接收请求后，查库，读文件，拼接好返回的http响应
5.浏览器收到html，开始渲染
6.解析html为dom，解析css为css-tree，最终生成render-tree阻塞渲染
7.遍历渲染树开始布局，计算每个节点的位置大小信息
8.将渲染树每个节点绘制到屏幕
9.加载js文件，运行js脚本
10.relow(样式)和repaint(位置)
```

### 简述同步和异步的区别？
```
- 在通信中，同步和异步强调的是消息的通信机制；而在计算机操作系统中，复用了通信里的概念，同步(Synchronous)是指在发生一个调用时，在没有得到结果之前，该调用不返回；异步(Asynchronous)是指在发生一个调用时，立即返回。
```

### 请简述常用的跨域方法(9种)
```
- cors
服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。

- jsonp
var script = document.createElement('script');  
script.src = "http://aa.xx.com/js/*.js";  
document.body.appendChild(script);

- postMessage
window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。

- window.name

- location.hash

- http-proxy

- nginx

- websocket

- iframe
基于iframe实现的跨域要求两个域具有aa.xx.com,bb.xx.com这种特点，也就是两个页面必须属于同一个顶级基础域（例如都是xxx.com，或是xxx.com.cn），使用同一协议（例如都是 http）和同一端口（例如都是80），这样在两个页面中同时添加document.domain，就可以实现父页面调用子页面的函数
```

### http常见的状态？
```
- 200("OK")一切正常。实体主体中的文档（若存在的话）是某资源的表示。
- 400("Bad Request")客户端方面的问题。实体主题中的文档（若存在的话）是一个错误消息。希望客户端能够理解此错误消息，并改正问题。
- 500("Internal Server Error")服务期方面的问题。实体主体中的文档（如果存在的话）是一个错误消息。该错误消息通常无济于事，因为客户端无法修复服务器方面的问题。
- 301("Moved Permanently")当客户端触发的动作引起了资源URI的变化时发送此响应代码。另外，当客户端向一个资源的旧URI发送请求时，也发送此响应代码。
- 404用于服务器端不知道客户端要请求哪个资源的情况；
- 410用于服务器端知道客户端所请求的资源曾经存在，但现在已经不存在了的情况。
- 409("Conflict")当客户端试图执行一个”会导致一个或多个资源处于不一致状态“的操作时，发送此响应代码。
```

### 请你简述下 SYN flood 攻击
```
> 攻击方伪造源地址发送 SYN 报文，服务端此时回复 syn+ack，但是真正的 IP 地址收到这个包之后，有可能直接回复了 RST 包，但是如果不回复 RST 包，那就更严重了，可能服务端会在几十秒后才关闭这个 socket 链接（时间根据每个系统不一样）
```

### TCP可以快速握手吗？
```
可以
1. 客户端发送一个SYN包，头部包含Fast Open选项的Cookie长度为0
2. 服务端根据客户端IP生成cookie，放在SYN+ACK包中一同发回客户端
3. 客户端收到Cookie以后缓存在自己的本地内存
4. 客户端再次访问服务端时，在SYN包携带数据，并在头部包含上次缓存在本地的TCP cookie
5. 如果服务端校验Cookie合法，则在客户端回复ACK前就可以直接发送数据。如果Cookie不合法，则按照正常三次握手进行
```

### TCP 链接和 UDP 的区别，什么时候选择使用 UDP 链接？
```
> Udp接收到应用协议的某个消息（已编码为二进制）后，不会分包，但是要记录当前数据包的大小（消息大小加上8个字节头部），然后交给IP层。而TCP接收到应用层协议的消息（已编码为二进制）后，然后参考该计算机连接的网络数据链路层MTU（最大传输单元）确定是否要分包，然后交给IP层。

UDP是非面向连接的，即发送数据之前不需要建立连接，而TCP则是面向连接的，也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。也就是说UDP管发不管到，而TCP管发管到。因此，在安全性方面来说，TCP更具有优越性。

Udp适用场合：如果需要做实时性很高且消息小（比如小于以太网的MTU1500Byte）的通信程序，UDP就很适合。关键消息重复发，不用等确认都可以，当然最终还是需要确认。如果是内网环境，网络非常稳定，UDP几乎不会出问题，如果极度要求性能，可以考虑。如果你公网网络资源有限，而用户之间需要传递大量数据，可以考虑用UDP做NAT穿透。				
```

### Chrome 打开一个页面需要启动多少进程？分别有哪些进程？
```
打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。
- 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。
```

### 如何保证页面文件能被完整送达浏览器？
```
> 互联网中的数据是通过数据包来传输的。数据包要在互联网上进行传输，就要符合网际协议(IP)，互联网上不同的在线设备都有唯一的地址，地址只是一个数字，只要知道这个具体的地址，就可以往这里发送信息。

如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机 A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 IP 头的数据结构里。IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。

IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给王者荣耀？因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是用户数据包协议（User Datagram Protocol)，简称UDP和传输控制协议（Transmission Control Protocol）,简称TCP.

基本传输过程为：
- 上层将数据包交给传输层
- 传输层会在数据包前面附加上UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层
- 网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层
- 数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层
- 在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序
- 最终，数据包就发送到了主机 B 上层应用程序这里。
```

### 为什么很多站点第二次打开速度会很快？
```
- DNS缓存
主要就是在浏览器本地把对应的 IP 和域名关联起来，这样在进行DNS解析的时候就很快。

- MemoryCache
是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。

- 浏览器缓存
浏览器缓存，也称Http缓存，分为强缓存和协商缓存。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。
    - 强缓存:强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。
    
    实现强缓存，过去我们一直用expires。当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段。像这样
    
    expires: Wed, 12 Sep 2019 06:12:18 GMT
    
    可以看到，expires 是一个时间戳，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。
    
    从这样的描述中大家也不难猜测，expires 是有问题的，它最大的问题在于对“本地时间”的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 expires 将无法达到我们的预期。
    
    考虑到 expires 的局限性，HTTP1.1 新增了Cache-Control字段来完成 expires 的任务。expires 能做的事情，Cache-Control 都能做；expires 完成不了的事情，Cache-Control 也能做。因此，Cache-Control 可以视作是 expires 的完全替代方案。在当下的前端实践里，我们继续使用 expires 的唯一目的就是向下兼容。

    cache-control: max-age=31536000

    在 Cache-Control 中，我们通过max-age来控制资源的有效期。max-age 不是一个时间戳，而是一个时间长度。在本例中，max-age 是 31536000 秒，它意味着该资源在 31536000 秒以内都是有效的，完美地规避了时间戳带来的潜在问题。

    Cache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。

    - 协商缓存:协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。
    
    协商缓存的实现,从 Last-Modified 到 Etag,Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：

    Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT

    随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：

    If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT

    服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。

    使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景：

    我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。

    当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。

    这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，Etag 作为 Last-Modified 的补充出现了。

    Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串可以是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。

    Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。

    Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。

- Service Worker Cache
Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。

Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件.

- Push Cache
Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶段，应用范围有限不代表不重要——HTTP2 是趋势、是未来。在它还未被推而广之的此时此刻，我仍希望大家能对 Push Cache 的关键特性有所了解：
    - Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。
    - Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。
    - 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。
```

### Ajax和Fetch区别
```
- ajax是使用XMLHttpRequest对象发起的，但是用起来很麻烦，所以ES6新规范就有了fetch，fetch发一个请求不用像ajax那样写一大堆代码。
- 使用fetch无法取消一个请求，这是因为fetch基于Promise，而Promise无法做到这一点。
- 在默认情况下，fetch不会接受或者发送cookies
- fetch没有办法原生监测请求的进度，而XMLHttpRequest可以
- fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理
- fetch由于是ES6规范，兼容性上比不上XMLHttpRequest
```

### 如何做到修改url参数页面不刷新
```
HTML5引入了 history.pushState() 和 history.replaceState() 方法，它们分别可以添加和修改历史记录条目。

let stateObj = {
    foo: "bar",
};

history.pushState(stateObj, "page 2", "bar.html");
假设当前页面为 foo.html，执行上述代码后会变为 bar.html，点击浏览器后退，会变为 foo.html，但浏览器并不会刷新。 pushState() 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个 URL. 让我们来解释下这三个参数详细内容：

- 状态对象 — 状态对象 state 是一个 JavaScript 对象，通过 pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate 事件就会被触发，且该事件的 state 属性包含该历史记录条目状态对象的副本。状态对象可以是能被序列化的任何东西。原因在于 Firefox 将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有640k的大小限制。如果你给 pushState() 方法传了一个序列化后大于 640k 的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 sessionStorage 以及 localStorage.
- 标题 — Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的 state 传递一个短标题。
- URL — 该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个 URL，但可能会在稍后某些情况下加载这个 URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前 URL 处理。新 URL 必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前 URL。
```

### RESTful是什么？
```
REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。

- GET
get方法在Rest中主要用于获取资源，能够发送参数，不过有限制，且参数都会以?开头的形 式附加在URL尾部。规范的get方法处理器应该是幂等的，也就是说对一个资源不论发送多少次get请求都不会更改数据或造成破坏。

- POST
post方法在Rest请求中主要用于添加资源，参数信息存放在请求报文的消息体中相对安全，且可发送较大信息

- PUT
put方法在Rest中主要用于更新资源，因为大多数浏览器不支持put和delete，会自动将put和delete请求转化为get和post. 因此为了使用put和delete方法, 需要以post发送请求，在表单中使用隐藏域发送真正的请求。put方法的参数是同post一样是存放在消息中的，同样具有安全性，可发送较大信息。put方法是幂等的，对同一URL资源做出的同一数据的任意次put请求其对数据的改变都是一致的。

- DELETE
Delete在Rest请求中主要用于删除资源，因为大多数浏览器不支持put和delete，会自动将put和delete请求转化为get和post。因此为了使用put和delete方法,需要以post发送请求，在表单中使用隐藏域发送真正的请求。Delete方法的参数同post一样存放在消息体中,具有安全性，可发送较大信息 Delete方法是幂等的，不论对同一个资源进行多少次delete请求都不会破坏数据
```

### GET和POST的区别
```
- GET产生一个TCP数据包；POST产生两个TCP数据包。
- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST么有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。
```

### Accept和Content-Type
```
Accept 请求头用来告知客户端可以处理的内容类型，这种内容类型用MIME类型来表示。服务器使用 Content-Type 应答头通知客户端它的选择。

Accept: text/html
Accept: image/*
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8

- Accept属于请求头， Content-Type属于实体头。
Http报头分为通用报头，请求报头，响应报头和实体报头。
请求方的http报头结构：通用报头|请求报头|实体报头
响应方的http报头结构：通用报头|响应报头|实体报头

- Accept代表发送端（客户端）希望接受的数据类型。
比如：Accept：text/xml;
代表客户端希望接受的数据类型是xml类型

Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。
比如：Content-Type：text/html;
代表发送端发送的数据格式是html。

二者合起来，
Accept:text/xml；
Content-Type:text/html
即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。
```

### Http与Https的区别
```
- HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
- HTTP 是不安全的，而 HTTPS 是安全的
- HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
- 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
- HTTP 无法加密，而HTTPS 对传输的数据进行加密
- HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书
```

### 什么是Http协议无状态协议?怎么解决Http协议无状态协议?
```
> 无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息也就是说，
当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。

可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，
当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。
```

### 常用的HTTP方法有哪些
```
- GET：用于请求访问已经被URL（统一资源标识符）识别的资源，可以通过URL传参给服务器。
- POST：用于传输信息给服务器，主要功能与Get方法类似，但一般推荐POST方式。
- PUT：传输文件，报文主体包含文件内容，保存到对应URL位置。
- HEAD：获取报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URL是否有效。
- DELETE：删除文件，与PUT方法相反，删除对应URL位置的文件。OPTIONS：查询相应URL支持的HTTP方法。
```

### 一次完整的HTTP请求所经历的7个步骤
```
HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：

- 建立TCP连接
在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。

- Web浏览器向Web服务器发送请求行
一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET /sample/hello.jsp HTTP/1.1。

- Web浏览器发送请求头
浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。

- Web服务器应答
客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。

- Web服务器发送应答头
正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

- Web服务器向浏览器发送数据
Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。

- Web服务器关闭TCP连接
一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：

Connection:keep-alive
TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

建立TCP连接->发送请求行->发送请求头->（到达服务器）发送状态行->发送响应头->发送响应数据->断TCP连接
```

### 关于建站安全防护
```
要做好防XSS、CSRF、SQL注入攻击.DDOS攻击。

- XSS概念:
译为跨站脚本攻击,具体是指攻击者在Web页面里插入恶意Script脚本，当用户浏览该网页时，Script代码会被执行，从而进行恶意攻击。

- XSS预防:
关键cookie字段设置httpOnly
输入检查,特殊字符 < > / &等,对其进行转义后存储

- CSRF概念：
本质上讲，是黑客将一个http接口中需要传递的所有参数都预测出来，然后不管以什么方式，他都可以根据他的目的来任意调用你的接口，对服务器实现CURD。

- CSRF 预防：
使用验证码，更高级用图灵测试

- SQL概念：
通常没有任何过滤，直接把参数存放到了SQL语句当中

- SQL预防：
根本上防止SQL注入的方法，就是参数化查询或者做词法分析。

- DDOS概念：
利用木桶原理，寻找利用系统应用的瓶颈；阻塞和耗尽；当前问题：用户的带宽小于攻击的规模，噪声访问带宽成为木桶的短板。

- DDOS预防：用软硬件结合的方式来防御是最有效的
```

### 为什么利用多个域名来提供网站资源会更有效？
```
1.CDN缓存更方便

2.突破浏览器并发限制
（一般每个域名建立的链接不超过6个）

3.Cookieless，节省带宽，
尤其是上行带宽一般比下行要慢;

4.对于UGC的内容和主站隔离，
防止不必要的安全问题
(上传js窃取主站cookie之类的)。
正是这个原因要求用户内容的域名
必须不是自己主站的子域名，
而是一个完全独立的第三方域名。

5.数据做了划分，
甚至切到了不同的物理集群，
通过子域名来分流比较省事。
```

### 什么是CDN, CDN对于网站有什么意义, 它有什么样的缺点?
```
CDN又称为内容分发网络;  本意在于
尽可能避开互联网上有可能影响数据
传输速度和稳定性的瓶颈和环节，
使内容传输的更快、更稳定。

主要目的:

解决因分布、带宽、服务器性能带来的访问延迟问题，
适用于站点加速、点播、直播等场景。

使用户可就近取得所需内容，
解决 Internet网络拥挤的状况，
提高用户访问网站的响应速度和成功率。

缺点:
- 实施复杂 , 投资大;
- 目前大部分的CDN还只是对静态内容加速，
对动态加速效果不好；
而双线对动态加速的效果跟静态是一样的。
```

## JavaScript

### 不声明第三个变量，变换两个变量中的值，共有几种方法
```
- 方案一：```a+=b;b=a-b;a-=b;```
- 方案二：```a^=b;b^=a;a^=b;```
- 方案三：```a=[a,b];b=a[0];a=a[1];```
- 方案四：```a=[b,b=a][0];```
- 方案五：```a={a:b,b:a};b=a.b;a=a.a;```
- 方案六：```[a,b]=[b,a];```
```

### es6的新特性有哪儿些？
```
- let 和 const
- Set 和 Map数据结构
- Class
- 模板字符串
- 箭头函数
- Itertor 和 for of 遍历索引数组和类数组对象 
- ... 参数增强和打散数组
- 解构 数组/对象/参数
- Promise
- Symbol 基本类型
- Reflect
- Proxy
- Decorator 装饰器
- es6 module es6模块
```

### 谈谈你对闭包的理解
```
- 闭包是函数和声明该函数的词法环境的组合。(MDN定义)
A clousure is the combination of a function and the lexical environment within which that function was declared.
注：离散数学中是对集合间关系的一种描述
- ECMAScript支持闭包，因而js中的闭包表现为：外层函数调用后，外层函数变量被内层函数对象的[[scope]]引用着而导致外层函数的作用域对象AO无法释放(垃圾回收));
- js中闭包常见作用：<1>.实现共有变量，如：函数累加器;<2>.可以做缓存(存储结构);<3>.属性私有化;<4>.模块化开发，防止污染全局变量
- js闭包的缺点：比普通函数占有更多内存(多的是外层函数作用域对象AO始终存在),容易造成内存泄漏
```

### 谈谈原型链继承的理解？
```
> 什么是原型链：只要是对象就有原型, 并且原型也是对象, 因此只要定义了一个对象, 那么就可以找到他的原型, 如此反复, 就可以构成一个对象的序列, 这个结构就被称为原型链
所有的实例有一个内部指针(prototype)，指向它的原型对象，并且可以访问原型对象上的所有属性和方法。
```

### Map和Set的区别
```
> Set 对象类似于数组，且成员的值都是唯一的。Map 对象是键值对集合，和 JSON 对象类似，但是 key 不仅可以是字符串还可以是对象
```

### 请简述js继承的六种方式
```
- 原型链继承
- 构造函数继承
- 组合继承
- 原型式继承
```
function object(o){
    function F(){};
    F.prototype=o;
    return new F();
}
```
- 寄生式继承
- 寄生组合式继承
```

### 请简述js创建对象的七种方式
```
- 工厂模式
- 构造函数模式
- 原型模式
- 动态原型模式
- 寄生构造函数模式
- 稳妥构造函数模式
```

### 请简述typeof可以判断的数据类型
```
- number(NaN)
- boolean
- string
- object(Null)
- undefined
- function
- symbol
```

### 请简述'=='和'==='的区别
```
- '==='会首先进行类型判断，屏蔽了自动类型转换;而'=='会先进行自动类型转换为数字后再比较。'==='是屏蔽了自动类型转换的'=='
```

### 请简述null和undefined的区别
```
- js底层undefined会被自动翻译成null；undefined可看做未赋值，null指曾赋过值，但是目前没有值；null是一个特殊关键字，不是标识符，不能当做变量来使用和赋值，而undefined却是一个标识符，可当作变量来使用和赋值
```

### 请简述Number(null)、Number(undefined)、Number(NaN)会返回的值
```
- Number(null)返回0，Number(undefined)返回NaN，Number(NaN)返回NaN，但是Number(undefined)==Number(NaN)返回false
```

### 如何判断NaN
```
- 只能通过isNaN判断
```

### 如何判断对象和数组
```
- isArray() es6语法
- Object.prototype.toString.call() 无兼容性问题
```

### 请简述this绑定规则
```
优先级：new绑定 > 显示绑定 > 隐式绑定 > 默认绑定
- 默认绑定 非严格模式下默认绑定指向全局对象，严格模式下默认绑定指向undefined
- 隐式绑定 存在隐式丢失现象，且对象属性引用链中只有最顶层会影响调用位置
- 显式绑定 硬绑定和api调用上下文可以解决隐式丢失问题
- new绑定
```

### 请简述new操作符执行过程
```
- 创建(或者说构造)一个全新的对象
- 这个对象会被执行[[prototype]]连接
- 这个新对象会绑定到函数调用的this
- 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象
```

### 请简述JavaScript中会更改原数组的操作有哪些？
```
- pop() 返回pop出来的元素
- push() 返回新数组的长度
- shift() 返回头部的元素
- unshift() 返回新数组的长度
- splice() 返回被删除元素的数组
- sort() 返回新数组
- reverse() 返回新数组
- fill() 返回新数组
- copyWithin() 返回新数组
```

### JavaScript中会返回false的哪些值？
```
- undefined
- null
- false
- +0、-0和NaN
- ""
```

### 什么是JSON安全值？
```
> undefined、function、symbol和包含循环引用的对象都不符合JSON的结构标准，JSON.stringify在对象中遇到undefined、function和symbol时会自动将其忽略，在数组中则会返回null
```

### 请简述ToString的转化规则
```
> 基本类型值的字符串化规则为null转换为"null"，undefined转换为"undefined"，true转换为"true"。数字的字符串转换遵循通用规则，极小和极大的数字使用指数形式。对普通对象来说，如无自行定义，toString()返回内部属性[[class]]的值
```

### 谈谈toString和String的区别？
```
- toString()方法；数值、字符串、对象、布尔；都有toString方法；这个方法唯一能做的就是返回相应的字符串；其中null和undefined没有toString()方法；
- String()属于强制转换， null转换的结果为null；undefined转换的结果为undefined；其余的如果有toString()方法，即调用该方法，返回相应的结果；
```

### 请简述ToNumber的转化规则
```
> true转化为1，false转化为0，undefined转化为NaN，null转化为0。对象会首先被转化为相应的基本类型，如果返回非数字的基本类型，则再遵循以上规则将其强制转换为数字
```

### 请简述ToBoolean的转化规则
```
> JavaScript中的值可以分为可以被强制类型转为false的值和其他，其中可以转换为假的值包括:undefined；null；false；+0、-0和NaN；""，其余均为真值
```

### 请简述ToPrimitive抽象操作
```
> 为了将值转换为相应的基本类型值，抽象操作ToPrimitive会首先通过内部操作DefaultValue，检查该值是否有valueOf()方法。如果有返回基本类型值，使用该值进行强制类型转换；如果没有就使用toString()的返回值(如果存在)来进行强制类型转换；如果valueOf()和toString()均不返回基本类型值，会产生TypeError错误。
```

### let,var和const有什么区别？
```
- const定义的变量不可以修改，而且必须初始化
- var定义的变量可以修改，如果不初始化会输出undefined，不会报错。
- let是块级作用域，函数内部使用let定义后，对函数外部无影响。
```

### 解释一下变量提升？
```
> 在进入一个执行上下文后，先把 var 和 function 声明的变量前置，再去顺序执行代码。
PS：作用域分为全局作用域和函数作用域，用var声明的变量，只在自己所在的所用域有效。
```

### 箭头函数和普通函数有什么区别？
```
主要区别在this指向问题
- 普通函数的this 指向调用它的那个对象，例如 obj.func ,那么func中的this就是obj
- 箭头函数不能作为构造函数，不能使用new，没有this，arguments箭头函数，箭头函数的this永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply()（或者说箭头函数中的this指向的是定义时的this，而不是执行时的this）
```

### 如何理解事件委托？
```
> 也可以称之为事件代理，给父元素绑定事件，用来监听子元素的冒泡事件，并找到是哪个子元素的事件。将事件委托给另外的元素，利用事件冒泡的特性，将里层的事件委托给外层事件，将事件绑定到目标元素的父节点，根据event对象的属性进行事件委托，改善性能。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。
```

### 求数组交集？并集？
```
- 直接使用 filter、concat 来计算
var a = [1,2,3,4,5]
var b = [2,4,6,8,10]
//交集
var c = a.filter(function(v){ return b.indexOf(v) > -1 })
//差集
var d = a.filter(function(v){ return b.indexOf(v) == -1 })
//补集
var e = a.filter(function(v){ return !(b.indexOf(v) > -1) })
.concat(b.filter(function(v){ return !(a.indexOf(v) > -1)}))
//并集
var f = a.concat(b.filter(function(v){ return !(a.indexOf(v) > -1)}));
console.log("数组a：", a);
console.log("数组b：", b);
console.log("a与b的交集：", c);
console.log("a与b的差集：", d);
console.log("a与b的补集：", e);
console.log("a与b的并集：", f);

- 借助扩展运算符（...）以及 Set 的特性实现相关计算，代码也会更加简单些

var b = [2,4,6,8,10]
console.log("数组a：", a);
console.log("数组b：", b);
var sa = new Set(a);
var sb = new Set(b);
// 交集
let intersect = a.filter(x => sb.has(x));
// 差集
let minus = a.filter(x => !sb.has(x));
// 补集
let complement = [...a.filter(x => !sb.has(x)), ...b.filter(x => !sa.has(x))];
// 并集
let unionSet = Array.from(new Set([...a, ...b]));
console.log("a与b的交集：", intersect);
console.log("a与b的差集：", minus);
console.log("a与b的补集：", complement);
console.log("a与b的并集：", unionSet);
```

### 将 Symbol 引入ES6 的目的是什么？
```
> Symbol 是一种新的、特殊的对象，可以用作对象中惟一的属性名。使用 Symbol 替换string 可以避免不同的模块属性的冲突。还可以将Symbol设置为私有，以便尚无直接访问Symbol权限的任何人都不能访问它们的属性。

Symbol 是JS新的基本数据类型。与number、string和boolean 原始类型一样，Symbol 也有一个用于创建它们的函数。与其他原始类型不同，Symbol没有字面量语法。创建它们的唯一方法是使用以下方法中的Symbol构造函数

let symbol = Symbol();    
```

### 解释一下原型设计模式(Prototype Pattern)
```
> 原型模式会创建新的对象，而不是创建未初始化的对象，它会返回使用从原型或样本对象复制的值进行初始化的对象。原型模式也称为属性模式。

原型模式有用的一个例子是使用与数据库中的默认值匹配的值初始化业务对象。原型对象保留默认值，这些默认值将被复制到新创建的业务对象中。

传统语言很少使用原型模式，但是JavaScript作为一种原型语言，在构建新对象及其原型时使用这种模式。
```

### ES6 中的临时死区是什么
```
> 在 ES6 中，let 和const 跟 var、class和function一样也会被提升，只是在进入作用域和被声明之间有一段时间不能访问它们，这段时间是临时死区(TDZ)。
```

### ES6 中的 WeakMap的实际用途是什么？
```
> WeakMaps 提供了一种从外部扩展对象而不影响垃圾收集的方法。当咱们想要扩展一个对象，但是因为它是封闭的或者来自外部源而不能扩展时，可以应用WeakMap。

WeakMap只适用于 ES6 或以上版本。WeakMap是键和值对的集合，其中键必须是对象。

WeakMaps的有趣之处在于，它包含了对map内部键的弱引用。弱引用意味着如果对象被销毁，垃圾收集器将从WeakMap中删除整个条目，从而释放内存。

> 和Map的区别：

当它们的键/值引用的对象被删除时，它们的行为都不同，以下面的代码为例:

var map=new Map();
var weakmap=new WeakMap();

(funciton(){
    var a={
        x:12
    };
    var b={
        y:12
    };
    map.set(a,1);
    weakmap.set(b,2);
})()

执行上面的 IIFE，就无法再引用{x：12}和{y：12}。垃圾收集器继续运行，并从 WeakMa中删除键b指针，还从内存中删除了{y：12}。

但在使用 Map的情况下，垃圾收集器不会从Map中删除指针，也不会从内存中删除{x：12}。

WeakMap 允许垃圾收集器执行其回收任务，但Map不允许。对于手动编写的 Map，数组将保留对键对象的引用，以防止被垃圾回收。但在WeakMap中，对键对象的引用被“弱”保留，这意味着在没有其他对象引用的情况下，它们不会阻止垃圾回收。
```

### 举一个柯里化函数的例子，并说明柯里化的好处？
```
> 柯里化是一种模式，其中一个具有多个参数的函数被分解成多个函数，当被串联调用时，这些函数将一次累加一个所需的所有参数。这种技术有助于使用函数式编写的代码更容易阅读和编写。需要注意的是，要实现一个函数，它需要从一个函数开始，然后分解成一系列函数，每个函数接受一个参数。

function curry(fn){
    if(fn.length===0){
        return fn;
    }

    function _curried(depth,args){
        return function(newArgument){
            if(depth-1===0){
                return fn(...args,newArgument)
            }
            return _curried(depth-1,[...args,newArgument]);
        }
    }

    return _curried(fn.length,[]);
}

function add(a,b){
    return a+b;
}

var curriedAdd=curry(add);
var addFive=curried(5);

var result=[0,1,2,3,4,5].map(addFive);
```

### 什么是域名收敛？
```
> PC 时代为了突破浏览器的域名并发限制。有了域名发散。
浏览器有并发限制，是为了防止DDOS攻击。
域名收敛：就是将静态资源放在一个域名下。减少DNS解析的开销。
域名发散：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。
域名发散是pc端为了利用浏览器的多线程并行下载能力。而域名收敛多用与移动端，提高性能，因为dns解析是是从后向前迭代解析，如果域名过多性能会下降，增加DNS的解析开销。
```

### target和currentTarget区别
```
- event.target
返回触发事件的元素

- event.currentTarget
返回绑定事件的元素
```

### 让异步编程更像同步编程，有几种方法？
```
- 回调函数实现
- 事件监听
- 发布订阅
- Promise/A+ 和生成器函数
- async/await
```

## CSS

### 水平垂直居中的方法有哪些？
```
- 绝对定位水平垂直居中
<div style="position: absolute;
     width: 500px;
     height: 300px;
     margin: auto;
     top: 0;
     left: 0;
     bottom: 0;
     right: 0;
     background-color: green;">水平垂直居中</div>

- 水平垂直居中
<div style="position: relative;
     width:400px;
     height:200px;
     top: 50%;
     left: 50%;
     margin: -100px 0 0 -200px;
     background-color: red;">水平垂直居中</div>

- 水平垂直居中
<div style="position: absolute;
     width:300px;
     height:200px;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
     background-color: blue;">水平垂直居中</div>

- flex 布局居中
<div style="display: flex;align-items: center;justify-content: center;">
    <div style="width: 100px;height: 100px;background-color: gray;">flex 布局</div>
  </div>
```

### 请写出你所知道的display属性的值
```
- display:none 此元素不会被显示
- display:block 此元素将显示为块级元素，此元素前后会带有换行符
- display:inline 此元素会被显示为内联元素，元素前后没有换行符
- display:inline-block 行内块元素，css2.1新增
- display:list-item 此元素会作为列表显示
- display:run-in 此元素会根据上下文作为块级元素或内两元素显示
- display:compact css2.1废除
- display:marker css2.1废除
- display:table 此元素会作为块级表格来显示，表格前后带有换行符
- display:inline-table 此元素会作为内联表格来显示，表格前后没有换行符
- display:table-row-group 此元素会作为一个或多个行的分组来显示(类似<tbody>)
- display:table-header-group 此元素会作为一个或多个行的分组来显示(类似<thead>)
- display:table-footer-group 此元素会作为一个或多个行的分组来显示(类似<tfoot>)
- display:table-row 此元素会作为一个表格行来显示(类似<tr>)
- display:table-column-group 此元素会作为一个或多个列的分组来显示(类似<colgroup>)
- display:table-column 此元素会作为一个单元格列显示(类似<col>)
- display:table-cell 此元素会作为一个表格单元格来显示(类似<td>和<th>)
- display:table-caption 此元素会作为一个表格标题来显示(类似<caption>)
- display:inherit 规定应该从父元素继承display属性的值
```

### 谈一谈CSS重绘与回流/重排？
```
会触发重绘或回流/重排的操作
- 添加、删除元素(回流+重绘)
- 隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流)
- 移动元素，如改变top、left或移动元素到另外1个父元素中(重绘+回流)
- 改变浏览器大小(回流+重绘)
- 改变浏览器的字体大小(回流+重绘)
- 改变元素的padding、border、margin(回流+重绘)
- 改变浏览器的字体颜色（只重绘，不回流）
- 改变元素的背景颜色（只重绘，不回流）

优化：
- 用transform 代替 top，left ，margin-top， margin-left... 这些位移属性
- opacity 加上 transform: translateZ/3d  这个属性之后便不会发生回流和重绘了
- 不要使用 js 代码对dom 元素设置多条样式，选择用一个 className 代替之。
- 如果确实需要用 js 对 dom 设置多条样式那么可以将这个dom 先隐藏，然后再对其设置
- 不要使用table 布局，因为table 的每一个行甚至每一个单元格的样式更新都会导致整个table 重新布局
- 对于频繁变化的元素应该为其加一个 transform 属性，对于视频使用video 标签
```

### px、em、rem的区别？
```
- 三者都是制作web网页时用到的单位
- px是实际像素大小，em是相对于父元素的像素大小，rem是相对于跟玉原石的像素大小
- IE6~8不支持em和rem属性
```

### css有哪些选择器？权重？
```
- 选择器类型：
    - ID　　#id
    - class　　.class
    - 标签　　p
    - 通用　　*
    - 属性　　[type="text"]
    - 伪类　　：hover
    - 伪元素　　::first-line
    - 子选择器、相邻选择器

- 权重计算规则：
    - 第一等：代表内联样式，如: style=””，权值为1000。
    - 第二等：代表ID选择器，如：#content，权值为0100。
    - 第三等：代表类，伪类和属性选择器，如.content，权值为0010。
    - 第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。
    - 通配符、子选择器、相邻选择器等的。如*、>、+,权值为0000。
    - 继承的样式没有权值。
```

### 说说flex布局？
```
> Flex（Flexible Box），也就是”弹性布局”，它可以很灵活地实现垂直居中、多列布局等自适应问题。而任何一个容器都可以指定为Flex布局。设为Flex布局以后，子元素的float、clear和vertical-align属性将失效
```

### 介绍一下盒模型
```
- 盒模型：内容(content)、填充(padding)、边界(margin)、 边框(border)
- 类型： IE 盒子模型、标准 W3C 盒子模型；
- 两种盒模型的主要区别是:标准盒模型的宽高是值内容宽高(content) 
- 而IE盒模型的宽高是指content+padding+border。
- 设置盒模型的方式是：设置box-sizing box-sizing:content-box  标准盒模型， box-sizing:border-box IE盒模型
```

### 重置（resetting）CSS 和 标准化（normalizing）CSS 的区别是什么？你会选择哪种方式，为什么？
```
- 重置（Resetting）：重置意味着除去所有的浏览器默认样式。对于页面所有的元素，像margin、padding、font-size这些样式全部置成一样。你将必须重新定义各种元素的样式。

- 标准化（Normalizing）：标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。

当需要实现非常个性化的网页设计时，我会选择重置的方式，因为我要写很多自定义的样式以满足设计需求，这时候就不再需要标准化的默认样式了。
```

### 请阐述Float定位的工作原理。
```
> 浮动（float）是 CSS 定位属性。浮动元素从网页的正常流动中移出，但是保持了部分的流动性，会影响其他元素的定位（比如文字会围绕着浮动元素）。这一点与绝对定位不同，绝对定位的元素完全从文档流中脱离。

CSS 的clear属性通过使用left、right、both，让该元素向下移动（清除浮动）到浮动元素下面。

如果父元素只包含浮动元素，那么该父元素的高度将塌缩为 0。我们可以通过清除（clear）从浮动元素后到父元素关闭前之间的浮动来修复这个问题。

有一种 hack 的方法，是自定义一个.clearfix类，利用伪元素选择器::after清除浮动。另外还有一些方法，比如添加空的<div></div>和设置浮动元素父元素的overflow属性。与这些方法不同的是，clearfix方法，只需要给父元素添加一个类，定义如下：

.clearfix::after {
  content: '';
  display: block;
  clear: both;
}
值得一提的是，把父元素属性设置为overflow: auto或overflow: hidden，会使其内部的子元素形成块格式化上下文（Block Formatting Context），并且父元素会扩张自己，使其能够包围它的子元素。
```

### 请阐述z-index属性，并说明如何形成层叠上下文（stacking context）。
```
> CSS 中的z-index属性控制重叠元素的垂直叠加顺序。z-index只能影响position值不是static的元素。

没有定义z-index的值时，元素按照它们出现在 DOM 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（static）的元素，而不管 HTML 层次结构如何。

层叠上下文是包含一组图层的元素。在一组层叠上下文中，其子元素的z-index值是相对于该父元素而不是 document root 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的z-index值，元素 C 也永远不会在元素 B 之上.

每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会在父层叠上下文中按顺序进行层叠。少数 CSS 属性会触发一个新的层叠上下文，例如opacity小于 1，filter不是none，transform不是none。
```

### 请阐述块格式化上下文（Block Formatting Context）及其工作原理。
```
块格式上下文（BFC）是 Web 页面的可视化 CSS 渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。

一个 HTML 盒（Box）满足以下任意一条，会创建块格式化上下文：

- float的值不是none.
- position的值不是static或relative.
- display的值是table-cell、table-caption、inline-block、flex、或inline-flex。
- overflow的值不是visible。

在 BFC 中，每个盒的左外边缘都与其包含的块的左边缘相接。

两个相邻的块级盒在垂直方向上的边距会发生合并（collapse）。更多内容请参考边距合并（margin collapsing）。
```

### 有哪些清除浮动的技术，都适用哪些情况？
```
- 空div方法：<div style="clear:both;"></div>。
- Clearfix 方法：上文使用.clearfix类已经提到。
- overflow: auto或overflow: hidden方法：上文已经提到。

在大型项目中，我会使用 Clearfix 方法，在需要的地方使用.clearfix。设置overflow: hidden的方法可能使其子元素显示不完整，当子元素的高度大于父元素时。
```

### 请解释什么是雪碧图（css sprites），以及如何实现？
```
雪碧图是把多张图片整合到一张上的图片。它被运用在众多使用了很多小图标的网站上（Gmail 在使用）。实现方法：

- 使用生成器将多张图片打包成一张雪碧图，并为其生成合适的 CSS。
- 每张图片都有相应的 CSS 类，该类定义了background-image、background-position和background-size属性。
- 使用图片时，将相应的类添加到你的元素中。

好处：

- 减少加载多张图片的 HTTP 请求数（一张雪碧图只需要一个请求）。但是对于 HTTP2 而言，加载多张图片不再是问题。
- 提前加载资源，防止在需要时才在开始下载引发的问题，比如只出现在:hover伪类中的图片，不会出现闪烁。
```

### 如何解决不同浏览器的样式兼容性问题？
```
- 在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。
- 使用已经处理好此类问题的库，比如 Bootstrap。
- 使用 autoprefixer 自动生成 CSS 属性前缀。
- 使用 Reset CSS 或 Normalize.css。
```

### 如何为功能受限的浏览器提供页面？使用什么样的技术和流程？
```
- 优雅的降级：为现代浏览器构建应用，同时确保它在旧版浏览器中正常运行。
- Progressive enhancement - The practice of building an application for a base level of user experience, but adding functional enhancements when a browser supports it.
- 渐进式增强：构建基于用户体验的应用，但在浏览器支持时添加新增功能。
- 利用 caniuse.com 检查特性支持。
- 使用 autoprefixer 自动生成 CSS 属性前缀。
- 使用 Modernizr进行特性检测。
```

### 有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？
```
这些方法与可访问性（a11y）有关。

- visibility: hidden：元素仍然在页面流中，并占用空间。
- width: 0; height: 0：使元素不占用屏幕上的任何空间，导致不显示它。
- position: absolute; left: -99999px：将它置于屏幕之外。
- text-indent: -9999px：这只适用于block元素中的文本。
- Metadata：例如通过使用 Schema.org，RDF 和 JSON-LD。
- WAI-ARIA：如何增加网页可访问性的 W3C 技术规范。

即使 WAI-ARIA 是理想的解决方案，我也会采用绝对定位方法，因为它具有最少的注意事项，适用于大多数元素，而且使用起来非常简单。
```

### 除了screen，你还能说出一个 @media 属性的例子吗？
```
- all
适用于所有设备。

- print
为了加载合适的文档到当前使用的可视窗口. 需要提前咨询 paged media（媒体屏幕尺寸）, 以满足个别设备网页尺寸不匹配等问题。

- screen
主要适用于彩色的电脑屏幕

- speech
解析speech这个合成器. 注意: CSS2已经有一个相似的媒体类型叫aural.
```

### 编写高效的 CSS 应该注意什么？
```
> 首先，浏览器从最右边的选择器，即关键选择器（key selector），向左依次匹配。根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作，去判断这些元素的父元素们是否匹配。

BEM (Block Element Modifier) methodology recommends that everything has a single class, and, where you need hierarchy, that gets baked into the name of the class as well, this naturally makes the selector efficient and easy to override. BEM (Block Element Modifier)原则上建议为独立的 CSS 类命名，并且在需要层级关系时，将关系也体现在命名中，这自然会使选择器高效且易于覆盖。

搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）和合成（compositing）。在写样式时，避免触发重新布局的可能。
```

### 使用 CSS 预处理的优缺点分别是什么？
```
- 优点：
    - 提高 CSS 可维护性。
    - 易于编写嵌套选择器。
    - 引入变量，增添主题功能。可以在不同的项目中共享主题文件。
    - 通过混合（Mixins）生成重复的 CSS。
    - Splitting your code into multiple files. CSS files can be split up too but doing so will require a HTTP request to download each CSS file.
    - 将代码分割成多个文件。不进行预处理的 CSS，虽然也可以分割成多个文件，但需要建立多个 HTTP 请求加载这些文件。

- 缺点：
    - 需要预处理工具。
    - 重新编译的时间可能会很慢
```

### 对于你使用过的 CSS 预处理，说说喜欢和不喜欢的地方？
```
- 喜欢：

    - 绝大部分优点上题以及提过。
    - Less 用 JavaScript 实现，与 NodeJS 高度结合。

- 不喜欢：

    - 我通过node-sass使用 Sass，它用 C ++ 编写的 LibSass 绑定。在 Node 版本切换时，我必须经常重新编译。
    - Less 中，变量名称以@作为前缀，容易与 CSS 关键字混淆，如@media、@import和@font-face。
```

### 如何实现一个使用非标准字体的网页设计？
```
> 使用@font-face并为不同的font-weight定义font-family。
```

### 解释浏览器如何确定哪些元素与 CSS 选择器匹配。
```
> 这部分与上面关于编写高效的 CSS 有关。浏览器从最右边的选择器（关键选择器）根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。

例如，对于形如p span的选择器，浏览器首先找到所有<span>元素，并遍历它的父元素直到根元素以找到<p>元素。对于特定的<span>，只要找到一个<p>，就知道'`已经匹配并停止继续匹配。
```

### 描述伪元素及其用途。
```
CSS 伪元素是添加到选择器的关键字，去选择元素的特定部分。它们可以用于装饰（:first-line，:first-letter）或将元素添加到标记中（与 content:...组合），而不必修改标记（:before，:after）。

- :first-line和:first-letter可以用来修饰文字。
- 上面提到的.clearfix方法中，使用clear: both来添加不占空间的元素。
- 使用:before和after展示提示中的三角箭头。鼓励关注点分离，因为三角被视为样式的一部分，而不是真正的 DOM。如果不使用额外的 HTML 元素，只用 CSS 样式绘制三角形是不太可能的。
```

### inline和inline-block有什么区别？
```
- block：
    - 大小：填充其父容器的宽度。
    - 定位：从新的一行开始，并且不允许旁边有 HTML 元素（除非是float） 
    - 能否设置width和height：能
    - 可以使用vertical-align对齐：不可以
    - 边距（margin）和填充（padding）： 各个方向都存在
    - 浮动（float）：-

- inline-block：
    - 大小：取决于内容。
    - 定位：与其他内容一起流动，并允许旁边有其他元素。
    - 能否设置width和height：能
    - 可以使用vertical-align对齐：可以
    - 边距（margin）和填充（padding）：各个方向都存在
    - 浮动（float）：-

- inline：
    - 大小：取决于内容。
    - 定位：与其他内容一起流动，并允许旁边有其他元素。
    - 能否设置width和height：不能。设置会被忽略。
    - 可以使用vertical-align对齐：可以
    - 边距（margin）和填充（padding）：只有水平方向存在。垂直方向会被忽略。尽管border和padding在content周围，但垂直方向上的空间取决于'line-height'
    - 浮动（float）：就像一个block元素，可以设置垂直边距和填充。
```

### relative、fixed、absolute和static四种定位有什么区别？
```
经过定位的元素，其position属性值必然是relative、absolute、fixed或sticky。

- static：默认定位属性值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。

- relative：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。

- absolute：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。

- fixed：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。

- sticky：盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky 对 table 元素的效果与 position: relative 相同。
```

### 你使用过哪些现有的 CSS 框架？你是如何改进它们的？
```
- Bootstrap：更新周期缓慢。Bootstrap 4 已经处于 alpha 版本将近两年了。添加了在页面中广泛使用的微调按钮组件。
- Semantic UI：源代码结构使得自定义主题很难理解。非常规主题系统的使用体验很差。外部库的路径需要硬编码（hard code）配置。变量重新赋值没有 Bootstrap 设计得好。
- Bulma：需要很多非语义的类和标记，显得很多余。不向后兼容，以至于升级版本后，会破坏应用的正常运行。
```

### 你了解 CSS Flex 和 Grid 吗？
```
- Flex：
flex容器中存在两条轴， 横轴和纵轴， 容器中的每个单元称为flex item。

在容器上可以设置6个属性： flex-direction flex-wrap flex-flow justify-content align-items align-content

注意：当设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。

Flex 项目属性

有六种属性可运用在 item 项目上: 1. order 2. flex-basis 3. flex-grow 4. flex-shrink 5. flex 6. align-self

- Grid：
CSS网格布局用于将页面分割成数个主要区域，或者用来定义组件内部元素间大小、位置和图层之间的关系。

像表格一样，网格布局让我们能够按行或列来对齐元素。但是，使用CSS网格可能还是比CSS表格更容易布局。例如，网格容器的子元素可以自己定位，以便它们像CSS定位的元素一样，真正的有重叠和层次。
```

### 响应式设计与自适应设计有何不同？
```
> 响应式设计和自适应设计都以提高不同设备间的用户体验为目标，根据视窗大小、分辨率、使用环境和控制方式等参数进行优化调整。

响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。

自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个。
```

### 你有没有使用过视网膜分辨率的图形？当中使用什么技术？
```
> 我倾向于使用更高分辨率的图形（显示尺寸的两倍）来处理视网膜显示。更好的方法是使用媒体查询，像@media only screen and (min-device-pixel-ratio: 2) { ... }，然后改变background-image。

对于图标类的图形，我会尽可能使用 svg 和图标字体，因为它们在任何分辨率下，都能被渲染得十分清晰。

还有一种方法是，在检查了window.devicePixelRatio的值后，利用 JavaScript 将<img>的src属性修改，用更高分辨率的版本进行替换。
```

### 什么情况下，用translate()而不用绝对定位？什么时候，情况相反。
```
> translate()是transform的一个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。而改变绝对定位会触发重新布局，进而触发重绘和复合。transform使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。因此translate()更高效，可以缩短平滑动画的绘制时间。

当使用translate()时，元素仍然占据其原始空间（有点像position：relative），这与改变绝对定位不同。
```

### display:none、visibile:hidden、opacity:0的区别
```
- display:none：
    - 是否隐藏：是
    - 是否在文档中占用空间：否
    - 是否会触发事件：否

- visible:hidden：
    - 是否隐藏：是
    - 是否在文档中占用空间：是
    - 是否会触发事件：否

- opacity:0：
    - 是否隐藏：是
    - 是否在文档中占用空间：是
    - 是否会触发事件：是
```

### 页面导入样式时，使用link和@import有什么区别？
```
- 用途：
    - @import只能引入css文件
    - link既能引入css，又能引入其它文件，比如：Vue脚手架唯一index.html中引入.ico图标
- 加载顺序：
    - 加载页面时，link标签引入的css被同时加载；
    - @import引入的css将在页面加载完毕后被加载
- 优先级：
    - @import中的样式虽然比link引入的css内容晚加载，但是，优先级却低于当前link引入的css内的其余样式
    - link支持使用DOM动态添加和改变，而@import用DOM操作不了
```

### css hack是什么
```
> 由于不同的浏览器，比如Internet Explorer 6,Internet Explorer 7,Mozilla Firefox等，对CSS的解析认识不一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。

这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。

这个针对不同的浏览器写不同的CSS code的过程，就叫CSS hack,也叫写CSS hack。
```

### 过渡与动画的区别是什么
```
- transition
可以在一定的时间内实现元素的状态过渡为最终状态，用于模拟以一种过渡动画效果，但是功能有限，只能用于制作简单的动画效果而动画属性

- animation
可以制作类似Flash动画，通过关键帧控制动画的每一步，控制更为精确，从而可以制作更为复杂的动画。
```

### 什么是外边距合并
```
> 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。

合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。
```

### 去除inline-block元素间间距的方法
```
- 移除空格
- 使用margin负值
- 使用font-size:0
- letter-spacing
- word-spacing
```

### CSS 去掉inline-block元素间隙的几种方法?
```
间隙是怎么来的:

间隙是由换行或者回车导致的;
只要把标签写成一行或者
标签直接没有空格，就不会出现间隙;

怎么去除?

方法1:
元素间的间隙出现的原因
是元素标签之间的空格，
把空格去掉间隙自然就会消失。
<div class="itlike">
  <span>撩课itlike</span><span>撩课itlike</span>
</div>

方法2:
利用HTML注释标签
<div class="demo">
    <span>撩课itlike</span>
    <!-- -->
    <span>撩课itlike</span>
</div>

方法3:
取消标签闭合
<div class="demo">
    <span>撩课itlike
    <span>撩课itlike
    <span>撩课itlike
    <span>撩课itlike
</div>

方法4:
在父容器上使用font-size:0;可以消除间隙
<div class="demo">
    <span>撩课itlike</span>
    <span>撩课itlike</span>
    <span>撩课itlike</span>
    <span>撩课itlike</span>
</div>
.demo {font-size: 0;}
```

## Node

### 请简述Node.js为什么处理异步IO快？
```
> Node 底层采用线程池的原理管理异步 IO，所以我们通常所的 单线程是指 Node 中 JavaScript 的执行是单线程的，但 Node 本身是多线程的。Node.js 中异步 IO 是通过事件循环的方式实现的，异步 IO 事件主要来源于网络请求和文件 IO。但是正因为如此，Node.js 处理很多计算密集型的任务，就比较吃力，当然有多进程方式可以解决这个问题。
```

### Node.js 有 cluster、fork 两种模式多进程，那么这两种情况下，主进程负责 TCP 通信，怎样才可以让子进程共享用户的 Socket 对象？
```
> cluster 模式，多实例、自动共享端口链接、自动实现负载均衡。fork 模式实现的多进程，单实例、多进程，可以通过手动分发 socket 对象给不同子进程进行定制化处理、实现负载均衡
```

### 请简述Node.js 多进程维护，以及通信方式
```
> 原生的 cluster 和 fork 模式都有 API 封装好的进行通信。如果是 execfile 这样形式调起第三方插件形式，想要与第三方插件进行通信，可以自己封装一个类似 promisyfy 形式进行通信，维护这块，子进程可以监听到异常，一旦发现异常，立刻通知主进程，杀死这个异常的子进程，然后重新开启一个子进程～
```

### 简单谈谈，Node.js 搭建 TCP、restful、websocket、UDP 服务器，遇到过哪些问题，怎么解决的
```
> 
```

### 请简述Koa洋葱模型
```
> 洋葱圈的实现，有点类似 Promise 中的 then 实现，每次通过 use 方法定义中间件函数时候，就会把这个函数存入一个队列中，全局维护一个 ctx 对象，每次调用 next()，就会调用队列的下一个任务函数。
use (fn) {
    // this.fn = fn 改成：
    this.middlewares.push(fn) // 每次use，把当前回调函数存进数组
}
compose(middlewares, ctx){ // 简化版的compose，接收中间件数组、ctx对象作为参数
    function dispatch(index){ // 利用递归函数将各中间件串联起来依次调用
        if(index === middlewares.length) return // 最后一次next不能执行，不然会报错
        let middleware = middlewares[index] // 取当前应该被调用的函数
        middleware(ctx, () => dispatch(index + 1)) // 调用并传入ctx和下一个将被调用的函数，用户next()时执行该函数
    }
    dispatch(0)
}
```

### Node.js 的消息队列应用场景是什么？原理是什么？
```
> 我们公司之前用的 kafka，消息队列的核心概念，异步，提供者，消费者。例如 IM 应用，每天都会有高峰期，但是我们不可能为了高峰期配置那么多服务器，那样就是浪费，所以使用消息队列，在多长时间内流量达到多少，就控制消费频率，例如客户端是流的提供者，有一个中间件消费队列，我们的服务器是消费者，每次消费一个任务就回复一个 ACK 给消费队列，消费频率由我们控制，这样任务不会丢失，服务器也不会挂。 还有一个异步问题，一个用户下单购买一件商品，可能要更新库存，已购数量，支付，下单等任务。不可能同步进行，这时候需要异步并行，事务方式处理。这样既不耽误时间，也能确保所有的任务成功才算成功，不然没有支付成功，但是已购数量增长了就有问题。
```

### 看你的技术栈对 Electron 比较熟悉，有使用过 React-native，请你谈谈使用的感受？
```
> React-native 的坑还是比较多，但是目前也算拥有成熟的生态了，开发简单的 APP 可以使用它。但是复杂的应用还是原生比较好，Electron 目前非常受欢迎，它基本上可以完成桌面应用的大部分需求，重型应用开发也是完全没问题的，可以配合大量 C# C++ 插件等。
```

### 你有提到白屏时间，有什么办法可以减少吗？都是什么原理？
```
> GZIP,SSR 同构、PWA 应用、预渲染、localStorage 缓存 js 文件等。

下面就是细分拆解答案，无限的连带问题，这里非常耗时，这些内容大都网上能搜到，我这里就不详细说

其中有问到 PWA 的原理，我的回答是：

Service Worker 有一套自己的声明周期，当安装并且处于激活状态时候，网站在 https 或者 localhost 的协议时候，可以拦截过滤发出的请求，会先把请求克隆一份（请求是流，消费就没有了），然后判断请求的资源是否在 Service Worker 缓存中，如果存在那么可以直接从 Service Worker 缓存中取出，如果不存在，那么就真正的发出这个请求。
```

### 介绍一下 Redis，为什么快，怎么做持久化存储？
```
> Redis 将数据存储在内存中，key-value 形式存储，所以获取也快。支持的 key 格式相对于 memorycache 更多，而且支持 RDB 快照形式、AOF。

> RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。RDB 是 Redis 默认的持久化方式，会在对应的目录下生产一个 dump.rdb 文件，重启会通过加载 dump.rdb 文件恢复数据。

优点：
1）只有一个文件 dump.rdb，方便持久化；
2）容灾性好，一个文件可以保存到安全的磁盘；
3）性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化（使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能) ；
4）如果数据集偏大，RDB 的启动效率会比 AOF 更高。

缺点：
1）数据安全性低。（RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不是特别严格的时候）
2）由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟。

> AOF 持久化是以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，文件中可以看到详细的操作记录。她的出现是为了弥补 RDB 的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。

优点：
1）数据安全性更高，AOF 持久化可以配置 appendfsync 属性，其中 always，每进行一次命令操作就记录到 AOF 文件中一次。
2）通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
3）AOF 机制的 rewrite 模式。(AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)

缺点
1）AOF 文件比 RDB 文件大，且恢复速度慢；数据集大的时候，比 RDB 启动效率低。
2）根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB。
```

### 介绍下缓存击穿和穿透
```
- 缓存穿透：是指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，如果 key 不存在或者 key 已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。

- 缓存击穿：是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。
```

### 介绍下你会用的自动化构建方式
```
1）Jenkins 自动化构建
2）自己搭建 Node.js 服务器，实现 Jenkins
3）Docker 配合 Travis CI 实现自动化构建

Jenkins 自动化构建：

配置，自动同步某个分支代码，打包构建。

自己搭建 Node.js 服务器，实现 Jenkins：

自己搭建 Node.js 的服务器，在 GitLab 上指定 webhook 地址，分支代码更新触发事件，服务器接受到 post 请求，里面附带分支的信息，执行自己的 shell 脚本命令，指定文件夹，构建打包。

服务器上使用 Docker-compose 指定镜像，每次代码推送到 gitHub，通过自己编写的 yml 和 dockerfile 文件构建打包，服务器自动拉取最新镜像并且发布到正式环境。
```

### 用户就是要上传 10 个 G 的文件，服务器存储允许的情况下，你会怎么处理保证整体架构顺畅，不影响其他用户？
```
> 我会准备两个服务器上传接口，前端或者原生客户端上传文件可以拿到文件大小，根据文件大小，分发不同的对应服务器接口处理上传，大文件可以进行断点续传，原理是 md5 生成唯一的 hash 值，将分片的 hash 数组先上传到后端，然后将文件分片上传，对比 hash 值，相同的则丢弃。不一致的话，根据数组内容进行 buffer 拼接生成文件。

断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。

首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。

因此在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。

前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。

当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。有了HTML5 的 File api之后切割文件比想想的要简单的多的多。

只要用slice 方法就可以了

var packet = file.slice(start, end);
参数start是开始切片的位置，end是切片结束的位置 单位都是字节。通过控制start和end 就可以是实现文件的分块

如

file.slice(0,1000);
file.slice(1000,2000);
file.slice(2000,3000);
// ......
在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。
```

### 谈谈你对前端、客户端架构的认识？
```
> 前端的架构，首先明确项目的兼容性，面向浏览器编程，是否做成 PC、移动端的响应式布局。根据项目规模、后期可能迭代的需求制定技术方案，如果比较重型的应用应该选用原生开发，尽量少使用第三方库。

客户端架构：是否跨平台，明确兼容系统，例如是否兼容 XP ，如果兼容 XP 就选择 nw.js，再然后根据项目复杂度招聘相应技术梯度人员，安排系统学习相关内容，招聘人员或者购买定制开发相关原生插件内容。

虽然说只是谈谈，但是感觉面试的职位越高级、轮数越往后，越考验你的架构能力，前面考察基础，后面考察你的技术广度以及逻辑思维，能否在复杂的应用中保持清醒头脑，定位性能这类型的细节能力。很多人基础面试面得很好，但是拿不到 offer，原因就是没有这种架构能力，只能自己写代码，不能带领大家学习、写代码。这也是我在面试时偶然听到某个大公司 HR 之间的对话，原话是：他面试还可以，看起来是很老实（某个之前的面试者），但是他对之前项目整体流程并不是那么清楚，连自己做的项目，前后端流程都不清楚，感觉不合适。
```

### 谈谈你对微前端的看法，以及实践：
```
> 将 Vue 和 React 一起开发，其实一点都不难，只要自己能造出 Redux 这样的轮子，熟悉两个框架原理，就能一起开发，难的是将这些在一个合适的场景中使用。之前看到网上有微前端的实践，但是并不是那么完美，当然，类似 Electron 这样的应用，混合开发很正常，微前端并不是只单单多个框架混合开发，更多是多个框架引入后解决了什么问题、带来的问题怎么解决？毕竟 5G 还没完全普及，数据传输还是不那么快。过大的包容易带来客户端的过长白屏时间（自己给自己挖坑）
```

## Vue

### MVVM和MVC的区别？
```
- MVC：MVC模式可以这样理解，将html看成view;js看成controller，处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）;将js的ajax当做Model，从服务器获取数据，MVC是单向的。
- MVVM：它实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变，MVVM是双向的。

Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表

MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。

（1）View 层

View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。

（2）Model 层

Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。

（3）ViewModel 层

ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。

MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。

我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：

（1）View 层

<div id="app">
    <p>{{message}}</p>
    <button v-on:click="showMessage()">Click me</button>
</div>
（2）ViewModel 层

var app = new Vue({
    el: '#app',
    data: {  // 用于描述视图状态
        message: 'Hello Vue!',
    },
    methods: {  // 用于描述视图行为
        showMessage(){
            let vm = this;
            alert(vm.message);
        }
    },
    created(){
        let vm = this;
        // Ajax 获取 Model 层的数据
        ajax({
            url: '/your/server/data/api',
            success(res){
                vm.message = res;
            }
        });
    }
})
（3） Model 层

{
    "url": "/your/server/data/api",
    "res": {
        "success": true,
        "name": "IoveC",
        "domain": "www.cnblogs.com"
    }
}

```

### 谈一谈vue的虚拟DOM是什么回事？
```
> Vue.js通过编译将模版转换成渲染函数(render)，执行渲染函数就可以得到一个虚拟DOM
简单点讲，在Vue的实现上，Vue讲模版编译成虚拟DOM渲染函数。结合Vue自带的响应系统，在状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应用到DOM操作上。

优点：

保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。
缺点:

无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。
```

### vue的双向数据绑定原理？
```
> 实现mvvm的双向绑定，是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

输入框内容变化时，Data 中的数据同步变化。即 View => Data 的变化。
Data 中的数据变化时，文本节点的内容同步变化。即 Data => View 的变化。
其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。

Vue 主要通过以下 4 个步骤来实现数据双向绑定的：

实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。

实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。

实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。

实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。

```

### vue组件通信？
```
- 父组件向子组件传值 --Props传递数据
在父组件中使用儿子组件
<template>
　　<div>
　　　　父组件：{{money}}
　　　　<Son1 :money="money"><Son1>
　　</div>
</template>
<script>
　　import Son1 from ''./Son1";
　　export default{
　　　　components:{
　　　　　　Son1
　　　　},
　　　　data(){
　　　　　　return { money: 100};
　　　　}
　　};
</script>
子组件接受数据
props:{
　　value:{
　　　　type:Number,
　　　　default:1
　　}
}
如果是数组
props:{
　　value:{
　　　　type:Array,
　　　　default: ()=>[]
　　}
}

- 子组件通信父组件 $emit使用
<template>
　　<div>
　　　　父组件：{{money}}
　　　　<Son1 :money="money" @input="change"><Son1>
　　</div>
</template>
<script>
　　import Son1 from ''./Son1";
　　export default{
　　　　methods:{
　　　　　change(data){
　　　　　　 this.money = data
　　　　　 }　
　　　　},
　　　　components:{
　　　　　　Son1
　　　　},
　　　　data(){
　　　　　　return { money: 100};
　　　　}
　　};
</script>
子组件触发绑定自己身上的方法
<template>
　　<div>
　　　　子组件1：{{money}}
　　　　<button @click="$emit('input',200)">修改父组件的值<Son1>
　　</div>
</template>
<script>
　　export default{
　　　　props:{
　　　　　money:{
　　　　　　 type:Number
　　　　　}
　　　　}
　　};
</script>

- $parent、$children（多层级传递）
<Grandson1 :value="value"></Grandson1>
<template>
　　<div>
　　　　孙子1：{{value}}
　　　　<---调用父组件的input事件-->
　　　　<button @click="$parent.$emit('input',200)">更改<Son1>
　　</div>
</template>
<script>
　　export default{
　　　　props:{
　　　　　value:{
　　　　　　 type:Number
　　　　　}
　　　　}
　　};
</script>

- $attrs、 $listeners：
$attrs批量向下传入属性：
<Son2 name="小明" age="18"></Son2>
<--可以在son2组件中使用$attrs,可以将属性继续向下传递-->
<div>
　　儿子2：{{  $attrs.name }}
　　<Grandson2  v-bind="$attrs"></Grandson2>
</div>
<tempalte>
　　<div>孙子：{{$attrs}}</div>
</template>
$listeners批量向下传入方法：
<Son2 name="小明" age="18" @click=“()=>{this.money  =500}”></Son2>
<--可以在son2组件中使用$attrs,可以将属性继续向下传递-->
<Grandson2  v-bind="$attrs" v-on="$listeners"></Grandson2>
<button @click="$listeners.click()">更改<Son1>

- Provide&Inject
Provide 在父级中注入数据
provide(){
　　return {parentMsg:'父亲'}；
}
Inject
在任意子组件中可以注入父级数据
inject：['parentMsg']//会将数据挂载在当前实例上

- ref使用
<Grandson2  name="花花" ref="grand2"></Grandson2>
mounted(){
　　console.log(this.$refs.grand2.name);
}

- EventBus：用于跨组件通知
Vue.prototype.$bus = new Vue();
Son2组件和Grandson1互相通信
mounted() {
　　//父亲组件注册
　　this.$bus.$on('my',data=>{
　　　　console.log(data)
　　})
}
mounted(){
　　//侄子组件调用
　　this.$nextTick(()=>{
　　　　this.$bus.$emit('my',"我是小红”);
　　})
}
```

### 父组件可以监听到子组件的生命周期吗？
```
比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：

// Parent.vue
<Child @mounted="doSomething"/>
    
// Child.vue
mounted() {
  this.$emit("mounted");
}
以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：

//  Parent.vue
<Child @hook:mounted="doSomething" ></Child>

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},
    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...
当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。
```

### vue中method，computed和watch三者的区别
```
> computed--适用于重新计算比较费时不用重复数据计算的环境。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。如果一个数据依赖于其他数据，那么把这个数据设计为computed
watch--像是一个 data 的数据监听回调，当依赖的 data 的数据变化，执行回调，在方法中会传入 newVal 和 oldVal。可以提供输入值无效，提供中间值 特场景。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。如果你需要在某个数据变化时做一些事情，使用watch。
method-- 跟前面的都不一样，我们通常在这里面写入方法，只要调用就会重新执行一次
```

### vue-router是怎么实现的？
```
vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：

switch (mode) {
  case 'history':
	this.history = new HTML5History(this, options.base)
	break
  case 'hash':
	this.history = new HashHistory(this, options.base, this.fallback)
	break
  case 'abstract':
	this.history = new AbstractHistory(this, options.base)
	break
  default:
	if (process.env.NODE_ENV !== 'production') {
	  assert(false, `invalid mode: ${mode}`)
	}
}

- hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。

早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：

hash 路由模式的实现主要是基于下面几个特性：

URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；
可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；
我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。

- history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。

HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：

window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
history 路由模式的实现主要基于存在下面几个特性：

pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；
我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；
history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。

- abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.
```

### 为什么 Vue 的 nextTick 不稳定？
```
> 在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。原因是什么呢，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中

优雅降级：首选 promise.then；然后是 setImmediate；然后是一个浏览器目前支持不好的 API
；最后是 setTimeout。dom 真正更新渲染好的时间，不能真正确定，不论是框架还是原生，都存在这个问题。所以用 nextTick 并不能保证拿到最新的 dom。
```

### vue中$set有什么用？
```
> 在我们使用vue进行开发的过程中，可能会遇到一种情况：当生成vue实例后，当再次给数据赋值时，有时候并不会自动更新到视图上去,因此可以使用$set。
initTableData() {
  this.tableData.forEach(element => {
      this.$set(element, 'edit', false)
  })
}

受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？

我们查看对应的 Vue 源码：vue/src/core/instance/index.js

export function set (target: Array<any> | Object, key: any, val: any): any {
  // target 为数组
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    // 修改数组的长度, 避免索引>数组长度导致splcie()执行有误
    target.length = Math.max(target.length, key)
    // 利用数组的splice变异方法触发响应式
    target.splice(key, 1, val)
    return val
  }
  // key 已经存在，直接修改属性值
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  // target 本身就不是响应式数据, 直接赋值
  if (!ob) {
    target[key] = val
    return val
  }
  // 对属性进行响应式处理
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}
我们阅读以上源码可知，vm.$set 的实现原理是：

如果目标是数组，直接使用数组的 splice 方法触发相应式；

如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）
```

### Vue 框架怎么实现对象和数组的监听？
```
> 如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：

  /**
   * Observe a list of Array items.
   */
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])  // observe 功能为监测数据的变化
    }
  }

  /**
   * 对属性进行递归遍历
   */
  let childOb = !shallow && observe(val) // observe 功能为监测数据的变化
通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。
```

### 

### vue生命周期的理解？
```
Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。
生命周期中有多个事件钩子，如下：
- beforeCreate（创建前） 在数据观测和初始化事件还未开始
- created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来
- beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。
- mounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。
- beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。
- updated（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。
- beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。
- destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。
```

### Vue 的父组件和子组件生命周期钩子函数执行顺序？
```
Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：

- 加载渲染过程：
父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

- 子组件更新过程：
父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

- 父组件更新过程：
父 beforeUpdate -> 父 updated

- 销毁过程：
父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed
```

### v-if和v-show的区别
```
> v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；
基于以上区别，因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。
```

### v-model 的原理？
```
我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：

text 和 textarea 元素使用 value 属性和 input 事件；
checkbox 和 radio 使用 checked 属性和 change 事件；
select 字段将 value 作为 prop 并将 change 作为事件。
以 input 表单元素为例：

<input v-model='something'>
    
相当于

<input v-bind:value="something" v-on:input="something = $event.target.value">
如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：

父组件：
<ModelChild v-model="message"></ModelChild>

子组件：
<div>{{value}}</div>

props:{
    value: String
},
methods: {
  test1(){
     this.$emit('input', '小红')
  },
},
```

### $route和$router的区别
```
- $router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。

- $route对象表示当前的路由信息，包含了当前 URL 解析得到的信息
**1.$route.path** 字符串，对应当前路由的路径，总是解析为绝对路径，如 "/foo/bar"。 
**2.$route.params** 一个 key/value 对象，包含了 动态片段 和 全匹配片段， 如果没有路由参数，就是一个空对象。
**3.$route.query** 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1， 如果没有查询参数，则是个空对象。
**4.$route.hash** 当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。锚点 
**5.$route.fullPath** 完成解析后的 URL，包含查询参数和 hash 的完整路径。
**6.$route.matched** 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。
**7.$route.name 当前路径名字** 
**8.$route.meta 路由元信息
```

### vue组件data为什么必须是函数？
```
> 如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。

// data
data() {
  return {
	message: "子组件",
	childName:this.name
  }
}

// new Vue
new Vue({
  el: '#app',
  router,
  template: '<App/>',
  components: {App}
})

因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。
```

### vue中怎么自定义指令？
```
- 定义全局的自定义变量
Vue.directive('color',{
  inserted(el){
//  各单位注意，这里的el获取的是标签元素，说白了就是可以直接操作DOM    console.log(el)
    el.style.color = "red"
  }
})

<div >前端伪大叔</div>
<div v-color>前端伪大叔</div>

- 组件内指令-只有自己组件可以使用
//  template
<div >前端伪大叔</div>
<div v-color>前端伪大叔</div>

//  script
directives:{
    color:{  
     inserted(el){
       el.style.color = 'cyan'
     }
   }
}
```

### 对keep-aerlive的了解？
```
> 通过设置了keep-alive，可以简单理解为从页面1跳转到页面2后，然后后退到页面1，只会加载缓存中之前已经渲染好的页面1，而不会再次重新加载页面1，及不会再触发页面一种的created等类似的钩子函数，除非自己重新刷新该页面1。
```

### Class 与 Style 如何动态绑定？
```
Class 可以通过对象语法和数组语法进行动态绑定：

- 对象语法：
<div v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>
data: {
  isActive: true,
  hasError: false
}

- 数组语法：
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}

Style 也可以通过对象语法和数组语法进行动态绑定：

- 对象语法：
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
data: {
  activeColor: 'red',
  fontSize: 30
}

- 数组语法：
<div v-bind:style="[styleColor, styleSize]"></div>
data: {
  styleColor: {
     color: 'red'
   },
  styleSize:{
     fontSize:'23px'
  }
}
```

### vue中key的作用？
```
> key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx > EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。

所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速

更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。

更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：

function createKeyToOldIdx (children, beginIdx, endIdx) {
  let i, key
  const map = {}
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key
    if (isDef(key)) map[key] = i
  }
  return map
}

强制替换元素，从而可以触发组件的生命周期钩子或者触发过渡。因为当key改变时，Vue认为一个新的元素产生了，从而会新插入一个元素来替换掉原有的元素。

<transition> <span :key="text">{{text}}</span> </transition>、

--这里如果text发生改变，整个<span>元素会发生更新，因为当text改变时，这个元素的key属性就发生了改变，在渲染更新时，Vue会认为这里新产生了一个元素，而老的元素由于key不存在了，所以会被删除，从而触发了过渡。
同理，key属性被用在组件上时，当key改变时会引起新组件的创建和原有组件的删除，此时组件的生命周期钩子就会被触发。
```

### vue中常用的路由钩子函数有哪一些？
```
- 全局守卫：
    - router.beforeEach 全局前置守卫 进入路由之前
    - router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用
    - router.afterEach 全局后置钩子 进入路由之后

- 路由组件内的守卫：
    - beforeRouteEnter 进入路由前
    - beforeRouteUpdate (2.2) 路由复用同一个组件时
    - beforeRouteLeave 离开当前路由时
```

### vue中常用的修饰符？
```
- .stop              //组织单击事件冒泡
- .prevent        //提交事件不再重新加载页面
- .capture        //添加事件侦听器时使用事件捕获模式
- .self              //只当事件在该元素本身时触发回调（在其子元素上不触发）
- .once             //只触发一次事件
```

### vuex中的成员？对应的作用？
```
- state => 基本数据 
- getters => 从基本数据派生的数据 
- mutations => 提交更改数据的方法，同步！
- actions => 像一个装饰器，包裹mutations，使之可以异步。
- modules => 模块化Vuex
```

### 使用过 Vue SSR 吗？说说 SSR？
```
> Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。

即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。

服务端渲染 SSR 的优缺点如下：

（1）服务端渲染的优点：

更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；
更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；
（2) 服务端渲染的缺点：

更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；
更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。
```

### 说说你对 SPA 单页面的理解，它的优缺点分别是什么？
```
SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

- 优点：
    - 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
    基于上面一点，SPA 相对对服务器压力小；
    - 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

- 缺点：
    - 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
    - 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
    - SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。
```

### Proxy 与 Object.defineProperty 优劣对比
```
- Proxy 的优势如下：
    - Proxy 可以直接监听对象而非属性；
    - Proxy 可以直接监听数组的变化；
    - Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；
    - Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；
    - Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；

- Object.defineProperty 的优势如下：
    - 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。
```

### Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？
```
受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？

我们查看对应的 Vue 源码：vue/src/core/instance/index.js

export function set (target: Array<any> | Object, key: any, val: any): any {
  // target 为数组
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    // 修改数组的长度, 避免索引>数组长度导致splcie()执行有误
    target.length = Math.max(target.length, key)
    // 利用数组的splice变异方法触发响应式
    target.splice(key, 1, val)
    return val
  }
  // key 已经存在，直接修改属性值
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  // target 本身就不是响应式数据, 直接赋值
  if (!ob) {
    target[key] = val
    return val
  }
  // 对属性进行响应式处理
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}
我们阅读以上源码可知，vm.$set 的实现原理是：

如果目标是数组，直接使用数组的 splice 方法触发相应式；

如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）
```

### 你有对 Vue 项目进行哪些优化？
```
- 代码层面的优化：
    - v-if 和 v-show 区分使用场景
    - computed 和 watch 区分使用场景
    - v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
    - 长列表性能优化
    - 事件的销毁
    - 图片资源懒加载
    - 路由懒加载
    - 第三方插件的按需引入
    - 优化无限列表性能
    - 服务端渲染 SSR or 预渲染

- Webpack 层面的优化：
    - Webpack 对图片进行压缩
    - 减少 ES6 转为 ES5 的冗余代码
    - 提取公共代码
    - 模板预编译
    - 提取组件的 CSS
    - 优化 SourceMap
    - 构建结果输出分析
    - Vue 项目的编译优化

- 基础的 Web 技术的优化：
    - 开启 gzip 压缩
    - 浏览器缓存
    - CDN的使用
    - 使用Chrome Performance 查找性能瓶颈
```

### 对于即将到来的 vue3.0 特性你有什么了解的吗？
```
Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：

（1）监测机制的改变

3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：

只能监测属性，不能监测对象

检测属性的添加和删除；

检测数组索引和长度的变更；

支持 Map、Set、WeakMap 和 WeakSet。

新的 observer 还提供了以下特性：

用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。
默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。
更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。
不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。
更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。
（2）模板

模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。

同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。

（3）对象式的组件声明方式

vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。

此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。

（4）其它方面的更改

vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：

支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。
支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。
基于 treeshaking 优化，提供了更多的内置功能。
```

## React

### 什么是虚拟DOM？
```
> 虚拟 DOM (VDOM)是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。
```

### 类组件和函数组件之间的区别是啥？
```
> 类组件可以使用其他特性，如状态 state 和生命周期钩子；当组件只是接收 props 渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。

区别：
- 是否有this：函数组件没有，类组件有
- 是否有生命周期：函数组件没有，类组件有
- 是否有状态state：函数组件没有，类组件有
```

### 解释 React 中 render() 的目的。
```
> 它被视为普通函数，但 render() 函数必须返回某些值，无论值是否为空。调用组件文件时默认会调用 render() 方法，因为组件需要显示 HTML 标记，或者我们可以说 JSX 语法。每个 React 组件必须有一个 render() 函数，它返回单个 React 元素，该元素代表原生 DOM 组件。如果需要渲染多个 HTML 元素，则必须将它们分组在一个封闭的标签内，如 <form>、<group>和 <div> 等。此函数必须保持纯净，就是说它在每次调用时必须返回相同的结果。
```

### React 中 refs 干嘛用的？
```
> Refs 提供了一种访问在render方法中创建的 DOM 节点或者 React 元素的方法。在典型的数据流中，props 是父子组件交互的唯一方式，想要修改子组件，需要使用新的pros重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用 Refs。

咱们可以在组件添加一个 ref 属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层 DOM 元素或组件的挂载实例。

class UnControlledForm extends Component{
    handleSubmit=()=>{
        console.log('Input Value：',this.input.value)
    }
    render(){
        return (
            <form onSubmit={this.handleSubmit}>
                <input
                    type='text'
                    ref={(input)=>this.input=input} />
                <button type='submit'>Submit</button>
            </form>
        )
    }
}

请注意，input 元素有一个ref属性，它的值是一个函数。该函数接收输入的实际 DOM 元素，然后将其放在实例上，这样就可以在 handleSubmit 函数内部访问它。

经常被误解的只有在类组件中才能使用 refs，但是refs也可以通过利用 JS 中的闭包与函数组件一起使用。

function CustomForm({handleSubmit}){
    let inputElement
    return (
        <form onSubmit={()=>handleSubmit(inputElement.value)}>
            <input
               type='text'
               ref={(input)=>inputElement=input} />
            <button type='submit'>Submit</button>
        </form>
    )
}
```

### 在 React 中如何处理事件
```
> 为了解决跨浏览器的兼容性问题，SyntheticEvent 实例将被传递给你的事件处理函数，SyntheticEvent是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。

比较有趣的是，React 实际上并不将事件附加到子节点本身。React 使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着 React 在更新 DOM 时不需要跟踪事件监听器。
```

### state 和 props 区别是啥？
```
> props和state是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即
- state 是组件自己管理数据，控制自己的状态，可变；
- props 是外部传入的数据参数，不可变；
- 没有state的叫做无状态组件，有state的叫做有状态组件；
- 多用 props，少用 state，也就是多写无状态组件。
```

### 有状态和无状态组件的区别。
```
- 有状态组件：
    - 在内存中存储组件状态更改的信息
    - 有权更改状态
    - 包含过去、现在和可能的未来状态更改的信息
    - 无安装组件爱你通知它们关于状态更改的需求，然后它们将props传递给前者

- 无状态组件：
    - 计算组件的内部状态
    - 无权更改状态
    - 没有包含关于状态更改的信息
    - 它们从有状态组件接收props，将其视为回调函数
```

### 如何创建 refs
```
> Refs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。

class MyComponent extends React.Component{
    constructor(props){
        super(props);
        this.myRef=React.createRef();
    }
    render(){
        return <div ref={this.myRef} />
    }
}

或者这样用：

class UserForm extends Component{
    handleSubmit=()=>{
        console.log('Input Value is:',this.input.value)
    }
    render(){
        return (
            <form onSubmit={this.handleSubmit}>
                <input 
                    type='text'
                    ref={(input)=>this.input=input} />
                <button type='submit'>Submit</button>
            </form>
        )
    }
}
```

### 什么是高阶组件？
```
> 高阶组件(HOC)是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为纯组件，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为。

const EnhancedComponent = higherOrderComponent(WrappedComponent);

HOC 可以用于以下许多用例：
- 代码重用、逻辑和引导抽象
- 渲染劫持
- state 抽象和操作
- props 处理
```

### 在构造函数调用 `super` 并将 `props` 作为参数传入的作用是啥？
```
> 在调用 super() 方法之前，子类构造函数无法使用this引用，ES6 子类也是如此。将 props 参数传递给 super() 调用的主要原因是在子构造函数中能够通过this.props来获取传入的 props。

传递props：

class MyComponent extends React.Component{
    constructor(props){
        super(props);
        console.log(this.props)
    }
}

没传递props：

class MyComponent extends React.Component{
    constructor(props){
        super();
        console.log(this.props); // undefined
        // 但是 Props 参数仍然可用
        console.log(props); // Prints {name:'sudheer',age:30}
    }
    render(){
        // 构造函数外部不受影响
        console.log(this.props) // {name:'sudheer',age:30}
    }
}

上面示例揭示了一点。props 的行为只有在构造函数中是不同的，在构造函数之外也是一样的。
```

### 什么是控制组件？
```
> 在 HTML 中，表单元素如 <input>、<textarea>和<select>通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。

而 React 的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如onChange)触发时重新渲染组件，因为状态被更新。以这种方式由 React 控制其值的输入表单元素称为受控组件。
```

### 如何 React.createElement ？
```
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
)

上述代码如何使用 React.createElement 来实现:

const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
```

### 讲讲什么是 JSX ？
```
> 当 Facebook 第一次发布 React 时，他们还引入了一种新的 JS 方言 JSX，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用Babel和webpack等工具将其转换为传统的JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一直了。

class MyComponent extends React.Component{
    render(){
        let props=this.props;
        return (
            <div className='my-component'>
            <a href={props.url}>{props.name}</a>
            </div>
        )
    }
}
```

### 为什么不直接更新 `state` 呢 ?
```
> 如果试图直接更新 state ，则不会重新渲染组件。

// 错误
This.state.message = 'Hello world';

需要使用setState()方法来更新 state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应：

// 正确做法
This.setState({message: ‘Hello World’});
```

### React 组件生命周期有哪些不同阶段？
```
在组件生命周期中有四个不同的阶段：
- Initialization：在这个阶段，组件准备设置初始化状态和默认属性。
- Mounting：react 组件已经准备好挂载到浏览器 DOM 中。这个阶段包括componentWillMount和componentDidMount生命周期方法。
- Updating：在这个阶段，组件以两种方式更新，发送新的 props 和 state 状态。此阶段包括shouldComponentUpdate、componentWillUpdate和componentDidUpdate生命周期方法。
- Unmounting：在这个阶段，组件已经不再被需要了，它从浏览器 DOM 中卸载下来。这个阶段包含 componentWillUnmount 生命周期方法。

除以上四个常用生命周期外，还有一个错误处理的阶段：

Error Handling：在这个阶段，不论在渲染的过程中，还是在生命周期方法中或是在任何子组件的构造函数中发生错误，该组件都会被调用。这个阶段包含了 componentDidCatch 生命周期方法。
```

### React 的生命周期方法有哪些？
```
- componentWillMount:在渲染之前执行，用于根组件中的 App 级配置。
- componentDidMount：在第一次渲染之后执行，可以在这里做AJAX请求，DOM 的操作或状态更新以及设置事件监听器。
- componentWillReceiveProps：在初始化render的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染
- shouldComponentUpdate：确定是否更新组件。默认情况下，它返回true。如果确定在 state 或 props 更新后组件不需要在重新渲染，则可以返回false，这是一个提高性能的方法。
- componentWillUpdate：在shouldComponentUpdate返回 true 确定要更新组件之前件之前执行。
- componentDidUpdate：它主要用于更新DOM以响应props或state更改。
- componentWillUnmount：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。
```

### 这三个点(…)在 React 干嘛用的？
```
> ... 在React（使用JSX）代码中做什么？它叫什么？

<Modal {...this.props} title='Modal heading'  animation={false}/>

这个叫扩展操作符号或者展开操作符，例如，如果this.props包含a：1和b：2，则

<Modal {...this.props} title='Modal heading' animation={false}>
等价于下面内容：
<Modal a={this.props.a} b={this.props.b} title='Modal heading' animation={false}>

扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新state 咱们就经常这么做：

this.setState(prevState => {
    return {foo: {...prevState.foo, a: "updated"}};
});
```

### 使用 React Hooks 好处是啥？
```
> 首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。

Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。
```

### 什么是 React Hooks？
```
> Hooks是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用state和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。
```

### React 中的 `useState()` 是什么？
```
const [count,setCounter]=useState(0);
const [moreStuff,setMoreStuff]=useState(...);

const setCount=()=>{
    setCounter(count+1);
    setMoreStuff(...);
}

useState 是一个内置的 React Hook。useState(0) 返回一个元组，其中第一个参数count是计数器的当前状态，setCounter 提供更新计数器状态的方法。

咱们可以在任何地方使用setCounter方法更新计数状态-在这种情况下，咱们在setCount函数内部使用它可以做更多的事情，使用 Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。
```

### React 中的StrictMode(严格模式)是什么？
```
> React 的StrictMode是一种辅助组件，可以帮助咱们编写更好的 react 组件，可以使用<StrictMode />包装一组组件，并且可以帮咱们以下检查：
- 验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告。
- 验证是否使用的已经废弃的方法，如果有，会在控制台给出警告。
- 通过识别潜在的风险预防一些副作用。
```

### 为什么类方法需要绑定到类实例？
```
> 在 JS 中，this 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 this 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:

class SubmitButton extends React.Component{
    constructor(props){
        super(props);
        this.state={
            isFormSubmitted:false
        };
        this.handleSubmit=this.handleSubmit.bind(this);
    }

    handleSubmit(){
        this.setState({
            isFormSubmitted:true
        })
    }

    render(){
        return (
            <button onClick={this.handleSubmit}>Submit</button>
        )
    }
}
```

### 什么是 prop drilling，如何避免？
```
> 在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 prop 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做prop drilling。

prop drilling的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。

为了避免prop drilling，一种常用的方法是使用React Context。通过定义提供数据的Provider组件，并允许嵌套的组件通过Consumer组件或useContext Hook 使用上下文数据。
```

### 描述 Flux 与 MVC？
```
> 传统的 MVC 模式在分离数据(Model)、UI(View和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:

- 数据流不够清晰:跨视图发生的级联更新常常会导致混乱的事件网络，难于调试。

- 缺乏数据完整性:模型数据可以在任何地方发生突变，从而在整个UI中产生不可预测的结果。

使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的React 组件都能够根据 store 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。
```

### 受控组件和非受控组件区别是啥？
```
- 受控组件是 React 控制中的组件，并且是表单数据真实的唯一来源。
- 非受控组件是由 DOM 处理表单数据的地方，而不是在 React 组件中。

尽管非受控组件通常更易于实现，因为只需使用refs即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。

这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式。
```

### 什么是 React Context?
```
> Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。
```

### 什么是 React Fiber?
```
> Fiber 是 React 16 中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。React Fiber 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。

React Fiber 的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中。
```

### 如何在 ReactJS 的 Props上应用验证？
```
> 当应用程序在开发模式下运行时，React 将自动检查咱们在组件上设置的所有 props，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的 props 用 isRequired定义的。

下面是一组预定义的 prop 类型
- React.PropTypes.string
- React.PropTypes.number
- React.PropTypes.func
- React.PropTypes.node
- React.PropTypes.bool

例如，咱们为用户组件定义了如下的propTypes

import PropTypes from 'prop-types';

class User extends React.Component{
    render(){
        return (
            <h1>Welcome,{this.props.name}</h1>
            <h2>Age,{this.props.age}</h2>
        )
    }
}

User.propTypes={
    name:PropTypes.string.isRequired,
    age:PropTypes.number.isRequired
}
```

### 在 React 中使用构造函数和 getInitialState 有什么区别？
```
> 构造函数和getInitialState之间的区别就是ES6和ES5本身的区别。在使用ES6类时，应该在构造函数中初始化state，并在使用React.createClass时定义getInitialState方法。

class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { /* initial state */ };
  }
}

等价于

var MyComponent = React.createClass({
  getInitialState() {
    return { /* initial state */ };
  },
});
```

### 如何有条件地向 React 组件添加属性？
```
> 对于某些属性，React 非常聪明，如果传递给它的值是虚值，可以省略该属性。例如：

var InputComponent=React.createClass({
    render:function(){
        var required=true;
        var disabled=false;

        return (
            <input type='text' disabled={disabled}
                required={required} />
        )
    }
})

渲染结果：

<input type="text" required>

另一种可能的方法是：

var condition = true;

var component = (
  <div
    value="foo"
    { ...( condition && { disabled: true } ) } />
);
```

### Hooks会取代 `render props` 和高阶组件吗？
```
> 通常，render props和高阶组件仅渲染一个子组件。React团队认为，Hooks 是服务此用例的更简单方法。

这两种模式仍然有一席之地(例如，一个虚拟的 scroller 组件可能有一个 renderItem prop，或者一个可视化的容器组件可能有它自己的 DOM 结构)。但在大多数情况下，Hooks 就足够了，可以帮助减少树中的嵌套。
```

### 如何避免组件的重新渲染？
```
> React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：
- React.memo():这可以防止不必要地重新渲染函数组件
- PureComponent:这可以防止不必要地重新渲染类组件

这两种方法都依赖于对传递给组件的props的浅比较，如果 props 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。

通过使用 React Profiler，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。
```

### 什么是纯函数？
```
> 纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。
```

### 当调用`setState`时，React `render` 是如何工作的？
```
> 咱们可以将"render"分为两个步骤：
- 虚拟 DOM 渲染:当render方法被调用时，它返回一个新的组件的虚拟 DOM 结构。当调用setState()时，render会被再次调用，因为默认情况下shouldComponentUpdate总是返回true，所以默认情况下 React 是没有优化的。
- 原生 DOM 渲染:React 只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。
```

### 如何避免在React重新绑定实例？
```
有几种常用方法可以避免在 React 中绑定方法：
- 将事件处理程序定义为内联箭头函数
class SubmitButton extends React.Component{
    constructor(props){
        super(props);
        this.state={
            isFormSubmitted:false
        };
    }

    render(){
        return (
            <button onClick={()=>{
                this.setState({isFormSubmitted:true})
            }}>Submit</button>
        )
    }
}

- 使用箭头函数来定义方法
class SubmitButton extends React.Component{
    state={
        isFormSubmitted:false
    }
    handleSubmit=()=>{
        this.setState({
            isFormSubmitted:true
        });
    }
    render(){
        return (
            <button onClick={this.handleSubmit}>Submit</button>
        )
    }
}

- 使用带有 Hooks 的函数组件
const SubmitButton=()=>{
    const [isFormSubmitted,setIsFormSubmitted]=useState(false);

    return (
        <button onClick={()=>{
            setIsFormSubmitted(true);
        }}>Submit</button>
    )
}
```

### 如何理解“单一可信源”？
```
> 单一可信源（SSOT）是构造信息模型和相关数据模式的实践，其中每个数据元素都只能在一个地方掌握（或编辑）
Redux 使用“存储”将应用程序的整个状态存储在一个位置。因此，组件的所有状态都存储在存储中，并且存储本身会接收更新。单一状态树使我们能更容易地跟踪历史更改，更方便地调试或检查应用程序。
```

### 列出 Redux 的组件。
```
- 动作——这是一个描述发生了什么的对象。
- Reducer——确定状态如何变化的地方。
- 存储——整个应用程序的状态 / 对象树保存在存储中。
- 视图——仅显示存储提供的数据。
```

### 在 Redux 中如何定义动作？
```
> React 中的动作必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，你也可以为其添加更多属性。在 Redux 中使用称为“动作创建者”的函数来创建动作。以下是动作和动作创建者的示例：

function addTodo(text) {
       return {
                type: ADD_TODO,
                 text
    }
}
```

### 说明 Reducer 的作用。	
```
> Reducer 是用于指示 ACTION 反应中应用程序状态变化的简单功能。它接收先前的状态和动作，然后返回新的状态。它根据动作类型确定需要哪种更新，然后返回新值。如果没有要完成的工作，它将按原样返回先前状态。
```

### 在 Redux 中存储的用途是什么？
```
> 存储是一个 JavaScript 对象，可以保存应用程序的状态，并提供一些辅助方法来访问状态、调度动作并记录侦听器。应用程序的整个状态 / 对象树存储在单个存储中。因此 Redux 非常容易理解且可预测。我们可以将中间件转移到存储，以管理数据处理任务，并维护更改存储状态的各种活动的日志。通过 Reducer，所有活动都返回新的状态。
```

### Redux 与 Flux 有何不同？
```
- Flux
    - 存储包括状态和更改逻辑
    - 有多个存储
    - 所有存储不互通，是平行的
    - 有单个调度器
    - React组件订阅到存储
    - 状态是可变的

- Redux
    - 存储和更改逻辑是分离的
    - 只有一个存储
    - 带有分层Reducer的单个存储
    - 没有调度器的概念
    - 容器组件是有联系的
    - 状态是不可变的
```

### Redux 有哪些优势？
```
Redux 的优点如下：
- 结果的可预测性——由于总是有单一可信源，比如存储，因此当前状态与动作及应用程序的其他部分同步时不会出现混乱。
- 可维护性——代码易于维护，具有可预测的结果和严格的结构。
- 服务端渲染——你只需将在服务器上创建的存储传递给客户端即可。这对于初始渲染非常有用，并优化了应用程序性能，提供了更好的用户体验。
- 开发人员工具——从动作到状态更改，开发人员可以利用这些工具实时跟踪应用程序中发生的所有事情。
- 社区和生态系统——Redux 背后拥有巨大的社区，用起来更加便利。大批优秀的开发者为库的发展做出了贡献，并开发了很多应用程序。
- 易于测试——Redux 的代码主要是较小的、纯净的和孤立的函数。这使代码可测试且独立。
- 组织——Redux 精确地规定了代码的组织方式，这使得团队合作时代码更加一致，更容易理解。
```

### 什么是 React Router？
```
> React Router 是建立在 React 之上的功能强大的路由库。它使 URL 与网页上显示的数据保持同步。它保持标准化的结构和行为，可用于开发单页 Web 应用程序。React Router 有一个简单的 API。React Router 提供了一种方法，只会显示你的应用中路由匹配你的定义的那些组件。
```

### 为什么我们在 React 中需要一个路由器？
```
> 路由器用于定义多个路由，并且当用户键入特定的 URL 时，如果该 URL 与路由器内部定义的任何“路由”的路径匹配，则该用户将被重定向到该路由。因此我们需要在应用程序中添加一个路由器库，以允许创建多个路由，每个路由都为我们指向一个独特的视图。

从 React Router 包导入的组件有两个属性，一个是将用户引导到指定路径的 path，另一个是用于定义所述路径中内容的 component。
```

### 列出 React Router 的优点。
```
- 就像 React 基于组件的理念一样，在 React Router v4 中 API 是“完全组件化的”。路由器可以可视化为单个根组件（<BrowserRouter>），其中包含特定的子路由（<route>）。

- 无需手动设置历史值：在 React Router v4 中，我们要做的就是将路由包装在<BrowserRouter>组件中。

- 包是拆分的：三个包分别用于 Web、Native 和 Core。这使我们的应用更加紧凑。它们的编码样式类似，所以很容易来回切换。
```

### React Router 与传统路由有何不同？
```
- 传统路由：
    - 参与的页面：每个视图对应一个新页面
    - URL更改：向服务器发送一个HTTP请求并接收对应的HTML页面
    - 体验：用户其实是在每个视图的不同页面间切换

- React路由：
    - 参与的页面：只涉及单个HTML页面
    - URL更改：只有历史属性被更改
    - 体验：用户以为自己正在不同的页面间切换
```

## 工程化

### 介绍一下webpack基本的属性？
```
const path = require('path')
module.exports = {
    entry: { // main是默认入口，也可以是多入口
        main: './src/main.js'
    },
    // 出口
    output: {
        filename: './build.js', // 指定js路径
        path: path.join(__dirname, '..', '', 'dist') // 最好是绝对路径
        // 代表上一级的dist
    },
    module: {
        // 一样的功能rules: webpack2.xx新加的
        loaders: [ // require('./a.css||./a.js')
            {
                test: /\.css$/,
                loader: 'style-loader!css=loader',
                //多个loader用!分割
                //顺序是反过来的 2!1  多个loader
            },
            {
                test: /\.(jpg|svg)$/,
                loaderL 'url-loader?limit=4096&name=[name].[ext]',
                // limit=4096&name=[name].[ext]' 多个参数之间用&符号分割
                //[name].[ext]内置提供的
                options: {
                    limit: 4096,
                    name: '[name].[ext]'
                }
            }
        ]  
    },
    plugins: [
        // 插件的执行顺序是依次执行的，和loader是反过来的
        new htmlWebpackPlugin({
            template: './src/index.html',
        })
        // 将src下的template属性描述的文件根据当前配置的output.path，将文件移动到该目录。
        // 在插件的执行过程中，它本身可以去拿当前所设置的webpack选项，便于对webpack选项的复用，
    ]
}
```

### 减少页面加载时间的方法
```
- 重复的HTTP请求数量应尽量减少
- 压缩Javascript、CSS代码
- 在文件头部放置css样式的定义
- 在文件末尾放Javascript脚本
- css、javascript改由外部调用，避免重复调用
- 尽可能减少DOM元素
- 避免使用CSS Expressions
- 添加文件过期或缓存头
- 使用CDN(Content Delivery Network)网络加速
- 服务器启用gzip压缩功能
- Ajax采用缓存调用
- 如果可以，Ajax调用尽量采用GET方法调用(其他方法会发送两次请求，一次option，一次为正常请求)
- 缩减iframe的使用，如无必要，尽量不要使用
- 合理使用Flush(后端)
- 避免采用301、302转向
- 优化图片文件
- 采用分页或翻页后展示
- 使用多域名负载网页内的多个文件、图片
```

### web前端性能优化
```
- 减少http请求，合理设置http缓存
- 使用浏览器缓存
- 启用压缩
- css sprites
- lazyload images
- css放最上部，js放最下面
- 异步请求callback
- 减少cookie传输
- JavaScript代码优化：
    - dom：html colleciton、重绘
    - 慎用with
    - 避免使用eval和Function
    - 减少作用域链查找
    - 数据访问
    - 字符串拼接
- css选择符优化
- cdn加速
- 反向代理
```

### babel转换es6语法工作原理？
```
> babel是一个转译器，感觉相对于编译器compiler，叫转译器transpiler更准确，因为它只是把同种语言的高版本规则翻译成低版本规则，而不像编译器那样，输出的是另一种更低级的语言代码。
但是和编译器类似，babel的转译过程也分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：

ES6代码输入 ==》 babylon进行解析 ==》 得到AST ==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树 ==》 用babel-generator通过AST树生成ES5代码
```