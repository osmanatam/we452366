# 简答题

### 不声明第三个变量，变换两个变量中的值，共有几种方法
```
- 方案一：```a+=b;b=a-b;a-=b;```
- 方案二：```a^=b;b^=a;a^=b;```
- 方案三：```a=[a,b];b=a[0];a=a[1];```
- 方案四：```a=[b,b=a][0];```
- 方案五：```a={a:b,b:a};b=a.b;a=a.a;```
- 方案六：```[a,b]=[b,a];```
```

### 如何判断浏览器的userAgent
```
- 如果userAgent中包含MSIE，说明一定是IE浏览器
- 如果userAgent中包含Trident却不包含MSIE，说明一定是IE11浏览器
- 如果userAgent中包含Firefox，说明一定是Firefox浏览器
- 如果userAgent中包含OPR，说明一定是Opera浏览器
- 如果userAgent中包含Edge，说明一定是Edge浏览器
- 如果userAgent中包含Edge，说明一定是Chrome浏览器
- 如果userAgent中包含Edge，说明一定是Edge浏览器
```

### 实现虚拟DOM树
```
var arr=[];
function getChildren(parent){
    var children=parent.children;
    for(var c of children){
        if(c.innerHTML.length>0){
            getChildren(c);
        }else{
            if(c.innerHTML=="{{uname}}"){
                c.innerHTML==data.uname;
                arr.push({
                    elem:c,
                    innerHTML:"{{uname}}"
                });
            }else if(c.innerHTML=="{{score}}"){
                c.innerHTML==data.score;
                arr.push({
                    elem:c,
                    innerHTML:"{{score}}"
                })
            }
        }
    }
};
//至少扫描一次
getChildren(nav);

//响应系统
Object.defineProperties(data,{
    _uname:{
        value:data.uname,
        writable:true,
        enumerable:false
    },
    uname:{
        get(){return this._uname},
        set(value){
            this._uname=value;
            for(var obj of arr){
                if(obj.innerHTML=="{{uname}}"){
                    obj.elem.innerHTML=value;
                }
            }
        }
    },
    _score:{
        value:data.score,
        writable:true,
        enumerable:false
    },
    score:{
        get(){return this._score},
        set(value){
            this._score=value;
            for(var obj of arr){
                if(obj.innerHTML=="{{score}}"){
                    obj.elem.innerHTML=value;
                }
            }
        }
    },
    enumerable:true
})
Object.seal(data);
```

### es6的新特性有哪儿些？
```
- let 和 const
- Set 和 Map数据结构
- Class
- 模板字符串
- 箭头函数
- Itertor 和 for of 遍历索引数组和类数组对象 
- ... 参数增强和打散数组
- 解构 数组/对象/参数
- Promise
- Symbol 基本类型
- Reflect
- Proxy
- Decorator 装饰器
- es6 module es6模块
```

### h5新特性有哪些?
```
- 语义化标签
- input表单类型增加 color date email search url tel number range month week
- 音频和视频
- canvas
- svg
- geolocation 地理定位
- drag&drop 拖放
- WebWorker Worker线程 PWA应用
- WebStorage 存储
- WebSocket 全双工通信 
- classlist
- fileReader
- Server-Sent Events(sse) 单向消息传递
- Application Cache 离线缓存
- Web SQL
- MathML 数学标记 基于xml ```<math xmlns="http://www.w3.org/1998/Math/MathML"></math>```
```

### 谈谈你对闭包的理解
```
- 闭包是函数和声明该函数的词法环境的组合。(MDN定义)
A clousure is the combination of a function and the lexical environment within which that function was declared.
注：离散数学中是对集合间关系的一种描述
- ECMAScript支持闭包，因而js中的闭包表现为：外层函数调用后，外层函数变量被内层函数对象的[[scope]]引用着而导致外层函数的作用域对象AO无法释放(垃圾回收));
- js中闭包常见作用：<1>.实现共有变量，如：函数累加器;<2>.可以做缓存(存储结构);<3>.属性私有化;<4>.模块化开发，防止污染全局变量
- js闭包的缺点：比普通函数占有更多内存(多的是外层函数作用域对象AO始终存在),容易造成内存泄漏
```

### 一个页面从输入url到页面加载显示完成，发生了什么？
```
1.浏览器通过DNS将url地址解析为ip(如果有缓存直接返回缓存，否则递归解析)
2.通过DNS解析得到了目标服务器的ip地址后，与服务器建立TCP连接。
    - ip协议：选择传输路线，负责找到
    - tcp协议：三次握手，分片，可靠传输，重新发送的机制
3.浏览器通过http协议发送请求(增加http的报文信息)头 体 行
4.服务器接收请求后，查库，读文件，拼接好返回的http响应
5.浏览器收到html，开始渲染
6.解析html为dom，解析css为css-tree，最终生成render-tree阻塞渲染
7.遍历渲染树开始布局，计算每个节点的位置大小信息
8.将渲染树每个节点绘制到屏幕
9.加载js文件，运行js脚本
10.relow(样式)和repaint(位置)
```

### 简述同步和异步的区别？
```
- 在通信中，同步和异步强调的是消息的通信机制；而在计算机操作系统中，复用了通信里的概念，同步(Synchronous)是指在发生一个调用时，在没有得到结果之前，该调用不返回；异步(Asynchronous)是指在发生一个调用时，立即返回。
```

### px、em、rem的区别？
```
- 三者都是制作web网页时用到的单位
- px是实际像素大小，em是相对于父元素的像素大小，rem是相对于跟玉原石的像素大小
- IE6~8不支持em和rem属性
```

### 水平垂直居中的方法有哪些？
```
```

### 减少页面加载时间的方法
```
- 重复的HTTP请求数量应尽量减少
- 压缩Javascript、CSS代码
- 在文件头部放置css样式的定义
- 在文件末尾放Javascript脚本
- css、javascript改由外部调用，避免重复调用
- 尽可能减少DOM元素
- 避免使用CSS Expressions
- 添加文件过期或缓存头
- 使用CDN(Content Delivery Network)网络加速
- 服务器启用gzip压缩功能
- Ajax采用缓存调用
- 如果可以，Ajax调用尽量采用GET方法调用(其他方法会发送两次请求，一次option，一次为正常请求)
- 缩减iframe的使用，如无必要，尽量不要使用
- 合理使用Flush(后端)
- 避免采用301、302转向
- 优化图片文件
- 采用分页或翻页后展示
- 使用多域名负载网页内的多个文件、图片
```

### 请写出你所知道的display属性的值
```
- display:none 此元素不会被显示
- display:block 此元素将显示为块级元素，此元素前后会带有换行符
- display:inline 此元素会被显示为内联元素，元素前后没有换行符
- display:inline-block 行内块元素，css2.1新增
- display:list-item 此元素会作为列表显示
- display:run-in 此元素会根据上下文作为块级元素或内两元素显示
- display:compact css2.1废除
- display:marker css2.1废除
- display:table 此元素会作为块级表格来显示，表格前后带有换行符
- display:inline-table 此元素会作为内联表格来显示，表格前后没有换行符
- display:table-row-group 此元素会作为一个或多个行的分组来显示(类似<tbody>)
- display:table-header-group 此元素会作为一个或多个行的分组来显示(类似<thead>)
- display:table-footer-group 此元素会作为一个或多个行的分组来显示(类似<tfoot>)
- display:table-row 此元素会作为一个表格行来显示(类似<tr>)
- display:table-column-group 此元素会作为一个或多个列的分组来显示(类似<colgroup>)
- display:table-column 此元素会作为一个单元格列显示(类似<col>)
- display:table-cell 此元素会作为一个表格单元格来显示(类似<td>和<th>)
- display:table-caption 此元素会作为一个表格标题来显示(类似<caption>)
- display:inherit 规定应该从父元素继承display属性的值
```

### 请简述js继承的六种方式
```
- 原型链继承
- 构造函数继承
- 组合继承
- 原型式继承
```
function object(o){
    function F(){};
    F.prototype=o;
    return new F();
}
```
- 寄生式继承
- 寄生组合式继承
```

### 请简述js创建对象的七种方式
```
- 工厂模式
- 构造函数模式
- 原型模式
- 动态原型模式
- 寄生构造函数模式
- 稳妥构造函数模式
```

### web前端性能优化
```
- 减少http请求，合理设置http缓存
- 使用浏览器缓存
- 启用压缩
- css sprites
- lazyload images
- css放最上部，js放最下面
- 异步请求callback
- 减少cookie传输
- JavaScript代码优化：
    - dom：html colleciton、重绘
    - 慎用with
    - 避免使用eval和Function
    - 减少作用域链查找
    - 数据访问
    - 字符串拼接
- css选择符优化
- cdn加速
- 反向代理
```

### 请简述常用的跨域方法(9种)
```
- cors
- jsonp
- postMessage
- document.domain
- window.name
- location.hash
- http-proxy
- nginx
- websocket
```

### 请简述typeof可以判断的数据类型
```
- number(NaN)
- boolean
- string
- object(Null)
- undefined
- function
- symbol
```

### 请简述'=='和'==='的区别
```
- '==='会首先进行类型判断，屏蔽了自动类型转换;而'=='会先进行自动类型转换为数字后再比较。'==='是屏蔽了自动类型转换的'=='
```

### 请简述null和undefined的区别
```
- js底层undefined会被自动翻译成null；undefined可看做未赋值，null指曾赋过值，但是目前没有值；null是一个特殊关键字，不是标识符，不能当做变量来使用和赋值，而undefined却是一个标识符，可当作变量来使用和赋值
```

### 请简述Number(null)、Number(undefined)、Number(NaN)会返回的值
```
- Number(null)返回0，Number(undefined)返回NaN，Number(NaN)返回NaN，但是Number(undefined)==Number(NaN)返回false
```

### 如何判断NaN
```
- 只能通过isNaN判断
```

### 如何判断对象和数组
```
- isArray() es6语法
- Object.prototype.toString.call() 无兼容性问题
```

### 请简述this绑定规则
```
优先级：new绑定 > 显示绑定 > 隐式绑定 > 默认绑定
- 默认绑定 非严格模式下默认绑定指向全局对象，严格模式下默认绑定指向undefined
- 隐式绑定 存在隐式丢失现象，且对象属性引用链中只有最顶层会影响调用位置
- 显式绑定 硬绑定和api调用上下文可以解决隐式丢失问题
- new绑定
```

### 请简述new操作符执行过程
```
- 创建(或者说构造)一个全新的对象
- 这个对象会被执行[[prototype]]连接
- 这个新对象会绑定到函数调用的this
- 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象
```

### 请简述JavaScript中会更改原数组的操作有哪些？
```
- pop() 返回pop出来的元素
- push() 返回新数组的长度
- shift() 返回头部的元素
- unshift() 返回新数组的长度
- splice() 返回被删除元素的数组
- sort() 返回新数组
- reverse() 返回新数组
- fill() 返回新数组
- copyWithin() 返回新数组
```

### JavaScript中会返回false的哪些值？
```
- undefined
- null
- false
- +0、-0和NaN
- ""
```

### 什么是JSON安全值？
```
> undefined、function、symbol和包含循环引用的对象都不符合JSON的结构标准，JSON.stringify在对象中遇到undefined、function和symbol时会自动将其忽略，在数组中则会返回null
```

### 请简述ToString的转化规则
```
> 基本类型值的字符串化规则为null转换为"null"，undefined转换为"undefined"，true转换为"true"。数字的字符串转换遵循通用规则，极小和极大的数字使用指数形式。对普通对象来说，如无自行定义，toString()返回内部属性[[class]]的值
```

### 请简述ToNumber的转化规则
```
> true转化为1，false转化为0，undefined转化为NaN，null转化为0。对象会首先被转化为相应的基本类型，如果返回非数字的基本类型，则再遵循以上规则将其强制转换为数字
```

### 请简述ToBoolean的转化规则
```
> JavaScript中的值可以分为可以被强制类型转为false的值和其他，其中可以转换为假的值包括:undefined；null；false；+0、-0和NaN；""，其余均为真值
```

### 请简述ToPrimitive抽象操作
```
> 为了将值转换为相应的基本类型值，抽象操作ToPrimitive会首先通过内部操作DefaultValue，检查该值是否有valueOf()方法。如果有返回基本类型值，使用该值进行强制类型转换；如果没有就使用toString()的返回值(如果存在)来进行强制类型转换；如果valueOf()和toString()均不返回基本类型值，会产生TypeError错误。
```

### 请简述V8引擎的垃圾回收机制
```
> 
```

### Doctype作用？标准模式与兼容模式各有什么区别？
```
> 声明位于HTML文档中的第一行，处于html标签之前，告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。
标准模式的排版和js运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器以防止站点无法工作过。
```






### 请简述Node.js为什么处理异步IO快？
```
> Node 底层采用线程池的原理管理异步 IO，所以我们通常所的 单线程是指 Node 中 JavaScript 的执行是单线程的，但 Node 本身是多线程的。Node.js 中异步 IO 是通过事件循环的方式实现的，异步 IO 事件主要来源于网络请求和文件 IO。但是正因为如此，Node.js 处理很多计算密集型的任务，就比较吃力，当然有多进程方式可以解决这个问题。
```

### Node.js 有 cluster、fork 两种模式多进程，那么这两种情况下，主进程负责 TCP 通信，怎样才可以让子进程共享用户的 Socket 对象？
```
> cluster 模式，多实例、自动共享端口链接、自动实现负载均衡。fork 模式实现的多进程，单实例、多进程，可以通过手动分发 socket 对象给不同子进程进行定制化处理、实现负载均衡
```

### 请简述Node.js 多进程维护，以及通信方式
```
> 原生的 cluster 和 fork 模式都有 API 封装好的进行通信。如果是 execfile 这样形式调起第三方插件形式，想要与第三方插件进行通信，可以自己封装一个类似 promisyfy 形式进行通信，维护这块，子进程可以监听到异常，一旦发现异常，立刻通知主进程，杀死这个异常的子进程，然后重新开启一个子进程～
```

### 简单谈谈，Node.js 搭建 TCP、restful、websocket、UDP 服务器，遇到过哪些问题，怎么解决的
```
> 
```

### 请简述Koa洋葱模型
```
> 洋葱圈的实现，有点类似 Promise 中的 then 实现，每次通过 use 方法定义中间件函数时候，就会把这个函数存入一个队列中，全局维护一个 ctx 对象，每次调用 next()，就会调用队列的下一个任务函数。
```
    use (fn) {
        // this.fn = fn 改成：
        this.middlewares.push(fn) // 每次use，把当前回调函数存进数组
    }
    compose(middlewares, ctx){ // 简化版的compose，接收中间件数组、ctx对象作为参数
        function dispatch(index){ // 利用递归函数将各中间件串联起来依次调用
            if(index === middlewares.length) return // 最后一次next不能执行，不然会报错
            let middleware = middlewares[index] // 取当前应该被调用的函数
            middleware(ctx, () => dispatch(index + 1)) // 调用并传入ctx和下一个将被调用的函数，用户next()时执行该函数
        }
        dispatch(0)
    }
```
```

### 请你简述下 SYN flood 攻击
```
> 攻击方伪造源地址发送 SYN 报文，服务端此时回复 syn+ack，但是真正的 IP 地址收到这个包之后，有可能直接回复了 RST 包，但是如果不回复 RST 包，那就更严重了，可能服务端会在几十秒后才关闭这个 socket 链接（时间根据每个系统不一样）
```

### TCP可以快速握手吗？
```
可以
1. 客户端发送一个SYN包，头部包含Fast Open选项的Cookie长度为0
2. 服务端根据客户端IP生成cookie，放在SYN+ACK包中一同发回客户端
3. 客户端收到Cookie以后缓存在自己的本地内存
4. 客户端再次访问服务端时，在SYN包携带数据，并在头部包含上次缓存在本地的TCP cookie
5. 如果服务端校验Cookie合法，则在客户端回复ACK前就可以直接发送数据。如果Cookie不合法，则按照正常三次握手进行
```

### TCP 链接和 UDP 的区别，什么时候选择使用 UDP 链接？
```
> Udp接收到应用协议的某个消息（已编码为二进制）后，不会分包，但是要记录当前数据包的大小（消息大小加上8个字节头部），然后交给IP层。而TCP接收到应用层协议的消息（已编码为二进制）后，然后参考该计算机连接的网络数据链路层MTU（最大传输单元）确定是否要分包，然后交给IP层。

UDP是非面向连接的，即发送数据之前不需要建立连接，而TCP则是面向连接的，也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。也就是说UDP管发不管到，而TCP管发管到。因此，在安全性方面来说，TCP更具有优越性。

Udp适用场合：如果需要做实时性很高且消息小（比如小于以太网的MTU1500Byte）的通信程序，UDP就很适合。关键消息重复发，不用等确认都可以，当然最终还是需要确认。如果是内网环境，网络非常稳定，UDP几乎不会出问题，如果极度要求性能，可以考虑。如果你公网网络资源有限，而用户之间需要传递大量数据，可以考虑用UDP做NAT穿透。				
```

### 为什么 Vue 的 nextTick 不稳定？
```
> 优雅降级：首选 promise.then；然后是 setImmediate；然后是一个浏览器目前支持不好的 API
；最后是 setTimeout。dom 真正更新渲染好的时间，不能真正确定，不论是框架还是原生，都存在这个问题。所以用 nextTick 并不能保证拿到最新的 dom。
```

### Node.js 的消息队列应用场景是什么？原理是什么？
```
> 我们公司之前用的 kafka，消息队列的核心概念，异步，提供者，消费者。例如 IM 应用，每天都会有高峰期，但是我们不可能为了高峰期配置那么多服务器，那样就是浪费，所以使用消息队列，在多长时间内流量达到多少，就控制消费频率，例如客户端是流的提供者，有一个中间件消费队列，我们的服务器是消费者，每次消费一个任务就回复一个 ACK 给消费队列，消费频率由我们控制，这样任务不会丢失，服务器也不会挂。 还有一个异步问题，一个用户下单购买一件商品，可能要更新库存，已购数量，支付，下单等任务。不可能同步进行，这时候需要异步并行，事务方式处理。这样既不耽误时间，也能确保所有的任务成功才算成功，不然没有支付成功，但是已购数量增长了就有问题。
```

### 看你的技术栈对 Electron 比较熟悉，有使用过 React-native，请你谈谈使用的感受？
```
> React-native 的坑还是比较多，但是目前也算拥有成熟的生态了，开发简单的 APP 可以使用它。但是复杂的应用还是原生比较好，Electron 目前非常受欢迎，它基本上可以完成桌面应用的大部分需求，重型应用开发也是完全没问题的，可以配合大量 C# C++ 插件等。
```

### 你有提到白屏时间，有什么办法可以减少吗？都是什么原理？
```
> GZIP,SSR 同构、PWA 应用、预渲染、localStorage 缓存 js 文件等。

下面就是细分拆解答案，无限的连带问题，这里非常耗时，这些内容大都网上能搜到，我这里就不详细说

其中有问到 PWA 的原理，我的回答是：

Service Worker 有一套自己的声明周期，当安装并且处于激活状态时候，网站在 https 或者 localhost 的协议时候，可以拦截过滤发出的请求，会先把请求克隆一份（请求是流，消费就没有了），然后判断请求的资源是否在 Service Worker 缓存中，如果存在那么可以直接从 Service Worker 缓存中取出，如果不存在，那么就真正的发出这个请求。
```

### 介绍一下 Redis，为什么快，怎么做持久化存储？
```
> Redis 将数据存储在内存中，key-value 形式存储，所以获取也快。支持的 key 格式相对于 memorycache 更多，而且支持 RDB 快照形式、AOF。

> RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。RDB 是 Redis 默认的持久化方式，会在对应的目录下生产一个 dump.rdb 文件，重启会通过加载 dump.rdb 文件恢复数据。

优点：
1）只有一个文件 dump.rdb，方便持久化；
2）容灾性好，一个文件可以保存到安全的磁盘；
3）性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化（使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能) ；
4）如果数据集偏大，RDB 的启动效率会比 AOF 更高。

缺点：
1）数据安全性低。（RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不是特别严格的时候）
2）由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟。

> AOF 持久化是以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，文件中可以看到详细的操作记录。她的出现是为了弥补 RDB 的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。

优点：
1）数据安全性更高，AOF 持久化可以配置 appendfsync 属性，其中 always，每进行一次命令操作就记录到 AOF 文件中一次。
2）通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
3）AOF 机制的 rewrite 模式。(AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)

缺点
1）AOF 文件比 RDB 文件大，且恢复速度慢；数据集大的时候，比 RDB 启动效率低。
2）根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB。
```

### 介绍下缓存击穿和穿透
```
- 缓存穿透：是指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，如果 key 不存在或者 key 已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。

- 缓存击穿：是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。
```

### 介绍下你会用的自动化构建方式
```
1）Jenkins 自动化构建
2）自己搭建 Node.js 服务器，实现 Jenkins
3）Docker 配合 Travis CI 实现自动化构建

Jenkins 自动化构建：

配置，自动同步某个分支代码，打包构建。

自己搭建 Node.js 服务器，实现 Jenkins：

自己搭建 Node.js 的服务器，在 GitLab 上指定 webhook 地址，分支代码更新触发事件，服务器接受到 post 请求，里面附带分支的信息，执行自己的 shell 脚本命令，指定文件夹，构建打包。

服务器上使用 Docker-compose 指定镜像，每次代码推送到 gitHub，通过自己编写的 yml 和 dockerfile 文件构建打包，服务器自动拉取最新镜像并且发布到正式环境。
```

### 用户就是要上传 10 个 G 的文件，服务器存储允许的情况下，你会怎么处理保证整体架构顺畅，不影响其他用户？
```
> 我会准备两个服务器上传接口，前端或者原生客户端上传文件可以拿到文件大小，根据文件大小，分发不同的对应服务器接口处理上传，大文件可以进行断点续传，原理是 md5 生成唯一的 hash 值，将分片的 hash 数组先上传到后端，然后将文件分片上传，对比 hash 值，相同的则丢弃。不一致的话，根据数组内容进行 buffer 拼接生成文件。
```

### 谈谈你对前端、客户端架构的认识？
```
> 前端的架构，首先明确项目的兼容性，面向浏览器编程，是否做成 PC、移动端的响应式布局。根据项目规模、后期可能迭代的需求制定技术方案，如果比较重型的应用应该选用原生开发，尽量少使用第三方库。

客户端架构：是否跨平台，明确兼容系统，例如是否兼容 XP ，如果兼容 XP 就选择 nw.js，再然后根据项目复杂度招聘相应技术梯度人员，安排系统学习相关内容，招聘人员或者购买定制开发相关原生插件内容。

虽然说只是谈谈，但是感觉面试的职位越高级、轮数越往后，越考验你的架构能力，前面考察基础，后面考察你的技术广度以及逻辑思维，能否在复杂的应用中保持清醒头脑，定位性能这类型的细节能力。很多人基础面试面得很好，但是拿不到 offer，原因就是没有这种架构能力，只能自己写代码，不能带领大家学习、写代码。这也是我在面试时偶然听到某个大公司 HR 之间的对话，原话是：他面试还可以，看起来是很老实（某个之前的面试者），但是他对之前项目整体流程并不是那么清楚，连自己做的项目，前后端流程都不清楚，感觉不合适。
```

### 谈谈你对微前端的看法，以及实践：
```
> 将 Vue 和 React 一起开发，其实一点都不难，只要自己能造出 Redux 这样的轮子，熟悉两个框架原理，就能一起开发，难的是将这些在一个合适的场景中使用。之前看到网上有微前端的实践，但是并不是那么完美，当然，类似 Electron 这样的应用，混合开发很正常，微前端并不是只单单多个框架混合开发，更多是多个框架引入后解决了什么问题、带来的问题怎么解决？毕竟 5G 还没完全普及，数据传输还是不那么快。过大的包容易带来客户端的过长白屏时间（自己给自己挖坑）
```