# 简答题

## 1.

## 2.实现数组的indexOf方法

### 答案：
```
function indexOf(arr,elem,fromi){
        //如果from有意义(不是false，""，undefined，null，NaN)，就用fromi继续后续执行
        //如果fromi没有意义（没有值），就用0作为备胎
        fromi=fromi||0;
        //从fromi位置开始遍历数组中剩余元素
        for(var i=fromi;i<arr.length;i++){
            //每遍历一个元素就用当前元素值和给的elem值做比较。只要碰上相等的，
            if(elem===arr[i]){
                return i;//就返回当前位置i并退出函数
            }
        }
        //如果循环结束都没退出，说明一个相同的都没找到，才有资格返回-1
        return -1;
    }
```

## 不声明第三个变量，变换两个变量中的值，共有几种方法

### 答案：
- 方案一：```a+=b;b=a-b;a-=b;```
- 方案二：```a^=b;b^=a;a^=b;```
- 方案三：```a=[a,b];b=a[0];a=a[1];```
- 方案四：```a=[b,b=a][0];```
- 方案五：```a={a:b,b:a};b=a.b;a=a.a;```
- 方案六：```[a,b]=[b,a];```

## 如何判断浏览器的userAgent

### 答案：
- 如果userAgent中包含MSIE，说明一定是IE浏览器
- 如果userAgent中包含Trident却不包含MSIE，说明一定是IE11浏览器
- 如果userAgent中包含Firefox，说明一定是Firefox浏览器
- 如果userAgent中包含OPR，说明一定是Opera浏览器
- 如果userAgent中包含Edge，说明一定是Edge浏览器
- 如果userAgent中包含Edge，说明一定是Chrome浏览器
- 如果userAgent中包含Edge，说明一定是Edge浏览器

## 6.实现虚拟DOM树

### 答案：
```
var arr=[];
function getChildren(parent){
    var children=parent.children;
    for(var c of children){
        if(c.innerHTML.length>0){
            getChildren(c);
        }else{
            if(c.innerHTML=="{{uname}}"){
                c.innerHTML==data.uname;
                arr.push({
                    elem:c,
                    innerHTML:"{{uname}}"
                });
            }else if(c.innerHTML=="{{score}}"){
                c.innerHTML==data.score;
                arr.push({
                    elem:c,
                    innerHTML:"{{score}}"
                })
            }
        }
    }
};
//至少扫描一次
getChildren(nav);

//响应系统
Object.defineProperties(data,{
    _uname:{
        value:data.uname,
        writable:true,
        enumerable:false
    },
    uname:{
        get(){return this._uname},
        set(value){
            this._uname=value;
            for(var obj of arr){
                if(obj.innerHTML=="{{uname}}"){
                    obj.elem.innerHTML=value;
                }
            }
        }
    },
    _score:{
        value:data.score,
        writable:true,
        enumerable:false
    },
    score:{
        get(){return this._score},
        set(value){
            this._score=value;
            for(var obj of arr){
                if(obj.innerHTML=="{{score}}"){
                    obj.elem.innerHTML=value;
                }
            }
        }
    },
    enumerable:true
})
Object.seal(data);
```

### es6的新特性有哪儿些？
- let 和 const
- Set 和 Map数据结构
- Class
- 模板字符串
- 箭头函数
- Itertor 和 for of 遍历索引数组和类数组对象 
- ... 参数增强和打散数组
- 解构 数组/对象/参数
- Promise
- Symbol 基本类型
- Reflect
- Proxy
- Decorator 装饰器
- es6 module es6模块

### h5新特性有哪些?
- 语义化标签
- input表单类型增加 color date email search url tel number range month week
- 音频和视频
- canvas
- svg
- geolocation 地理定位
- drag&drop 拖放
- WebWorker Worker线程 PWA应用
- WebStorage 存储
- WebSocket 全双工通信 
- classlist
- fileReader
- Server-Sent Events(sse) 单向消息传递
- Application Cache 离线缓存
- Web SQL
- MathML 数学标记 基于xml ```<math xmlns="http://www.w3.org/1998/Math/MathML"></math>```

### 谈谈你对闭包的理解
- 闭包是函数和声明该函数的词法环境的组合。(MDN定义)
A clousure is the combination of a function and the lexical environment within which that function was declared.
注：离散数学中是对集合间关系的一种描述
- ECMAScript支持闭包，因而js中的闭包表现为：外层函数调用后，外层函数变量被内层函数对象的[[scope]]引用着而导致外层函数的作用域对象AO无法释放(垃圾回收));
- js中闭包常见作用：<1>.实现共有变量，如：函数累加器;<2>.可以做缓存(存储结构);<3>.属性私有化;<4>.模块化开发，防止污染全局变量
- js闭包的缺点：比普通函数占有更多内存(多的是外层函数作用域对象AO始终存在),容易造成内存泄漏

### 一个页面从输入url到页面加载显示完成，发生了什么？
1.浏览器通过DNS将url地址解析为ip(如果有缓存直接返回缓存，否则递归解析)
2.通过DNS解析得到了目标服务器的ip地址后，与服务器建立TCP连接。
    - ip协议：选择传输路线，负责找到
    - tcp协议：三次握手，分片，可靠传输，重新发送的机制
3.浏览器通过http协议发送请求(增加http的报文信息)头 体 行
4.服务器接收请求后，查库，读文件，拼接好返回的http响应
5.浏览器收到html，开始渲染
6.解析html为dom，解析css为css-tree，最终生成render-tree阻塞渲染
7.遍历渲染树开始布局，计算每个节点的位置大小信息
8.将渲染树每个节点绘制到屏幕
9.加载js文件，运行js脚本
10.relow(样式)和repaint(位置)

## 15.简述同步和异步的区别？

### 答案：
- 在通信中，同步和异步强调的是消息的通信机制；而在计算机操作系统中，复用了通信里的概念，同步(Synchronous)是指在发生一个调用时，在没有得到结果之前，该调用不返回；异步(Asynchronous)是指在发生一个调用时，立即返回。

### px、em、rem的区别？
- 三者都是制作web网页时用到的单位
- px是实际像素大小，em是相对于父元素的像素大小，rem是相对于跟玉原石的像素大小
- IE6~8不支持em和rem属性

## 17.水平垂直居中的方法有哪些？

### 答案：


### 减少页面加载时间的方法
- 重复的HTTP请求数量应尽量减少
- 压缩Javascript、CSS代码
- 在文件头部放置css样式的定义
- 在文件末尾放Javascript脚本
- css、javascript改由外部调用，避免重复调用
- 尽可能减少DOM元素
- 避免使用CSS Expressions
- 添加文件过期或缓存头
- 使用CDN(Content Delivery Network)网络加速
- 服务器启用gzip压缩功能
- Ajax采用缓存调用
- 如果可以，Ajax调用尽量采用GET方法调用(其他方法会发送两次请求，一次option，一次为正常请求)
- 缩减iframe的使用，如无必要，尽量不要使用
- 合理使用Flush(后端)
- 避免采用301、302转向
- 优化图片文件
- 采用分页或翻页后展示
- 使用多域名负载网页内的多个文件、图片

### 请写出你所知道的display属性的值
- display:none 此元素不会被显示
- display:block 此元素将显示为块级元素，此元素前后会带有换行符
- display:inline 此元素会被显示为内联元素，元素前后没有换行符
- display:inline-block 行内块元素，css2.1新增
- display:list-item 此元素会作为列表显示
- display:run-in 此元素会根据上下文作为块级元素或内两元素显示
- display:compact css2.1废除
- display:marker css2.1废除
- display:table 此元素会作为块级表格来显示，表格前后带有换行符
- display:inline-table 此元素会作为内联表格来显示，表格前后没有换行符
- display:table-row-group 此元素会作为一个或多个行的分组来显示(类似<tbody>)
- display:table-header-group 此元素会作为一个或多个行的分组来显示(类似<thead>)
- display:table-footer-group 此元素会作为一个或多个行的分组来显示(类似<tfoot>)
- display:table-row 此元素会作为一个表格行来显示(类似<tr>)
- display:table-column-group 此元素会作为一个或多个列的分组来显示(类似<colgroup>)
- display:table-column 此元素会作为一个单元格列显示(类似<col>)
- display:table-cell 此元素会作为一个表格单元格来显示(类似<td>和<th>)
- display:table-caption 此元素会作为一个表格标题来显示(类似<caption>)
- display:inherit 规定应该从父元素继承display属性的值

### 请简述js继承的六种方式
- 原型链继承
- 构造函数继承
- 组合继承
- 原型式继承
```
function object(o){
    function F(){};
    F.prototype=o;
    return new F();
}
```
- 寄生式继承
- 寄生组合式继承

### 请简述js创建对象的七种方式
- 工厂模式
- 构造函数模式
- 原型模式
- 动态原型模式
- 寄生构造函数模式
- 稳妥构造函数模式

### web前端性能优化
- 减少http请求，合理设置http缓存
- 使用浏览器缓存
- 启用压缩
- css sprites
- lazyload images
- css放最上部，js放最下面
- 异步请求callback
- 减少cookie传输
- JavaScript代码优化：
    - dom：html colleciton、重绘
    - 慎用with
    - 避免使用eval和Function
    - 减少作用域链查找
    - 数据访问
    - 字符串拼接
- css选择符优化
- cdn加速
- 反向代理
