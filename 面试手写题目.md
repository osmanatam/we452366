# 2019面试手写题

## 1.如何用ES5实现实现两种类型间的继承--手写

## 2.实现数组的indexOf方法

### 答案：
```
function indexOf(arr,elem,fromi){
        //如果from有意义(不是false，""，undefined，null，NaN)，就用fromi继续后续执行
        //如果fromi没有意义（没有值），就用0作为备胎
        fromi=fromi||0;
        //从fromi位置开始遍历数组中剩余元素
        for(var i=fromi;i<arr.length;i++){
            //每遍历一个元素就用当前元素值和给的elem值做比较。只要碰上相等的，
            if(elem===arr[i]){
                return i;//就返回当前位置i并退出函数
            }
        }
        //如果循环结束都没退出，说明一个相同的都没找到，才有资格返回-1
        return -1;
    }
```

## 3.不声明第三个变量，变换两个变量中的值，共有几种方法

### 答案：
- 方案一：```a+=b;b=a-b;a-=b;```
- 方案二：```a^=b;b^=a;a^=b;```
- 方案三：```a=[a,b];b=a[0];a=a[1];```
- 方案四：```a=[b,b=a][0];```
- 方案五：```a={a:b,b:a};b=a.b;a=a.a;```
- 方案六：```[a,b]=[b,a];```

## 4.实现支持Promise的原生ajax函数

### 答案：
```
function ajax(url,method,fn,type){
    return new Promise((resolve,reject)=>{
            var xhr=new XMLHttpRequest();
            xhr.onreadystatechange=function(){
                if(xhr.readyState==4){
                    if(xhr.status==200){
                        //var result=xhr.responseText;
                        //fn(result);
                        resolve(JSON.parse(xhr.responseText).count);
                    }	
                }
            };

            xhr.open(method,url+"?"+type,true);

            if(method=="post"){
                xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
            }

            if(method=="get"){
                xhr.send(null);
            }else if(method=="post"){
                xhr.send(type);
            }

        }
    )	
}
```

## 5.如何判断浏览器的userAgent

### 答案：
- 如果userAgent中包含MSIE，说明一定是IE浏览器
- 如果userAgent中包含Trident却不包含MSIE，说明一定是IE11浏览器
- 如果userAgent中包含Firefox，说明一定是Firefox浏览器
- 如果userAgent中包含OPR，说明一定是Opera浏览器
- 如果userAgent中包含Edge，说明一定是Edge浏览器
- 如果userAgent中包含Edge，说明一定是Chrome浏览器
- 如果userAgent中包含Edge，说明一定是Edge浏览器

## 6.实现虚拟DOM树

### 答案：
```
var arr=[];
function getChildren(parent){
    var children=parent.children;
    for(var c of children){
        if(c.innerHTML.length>0){
            getChildren(c);
        }else{
            if(c.innerHTML=="{{uname}}"){
                c.innerHTML==data.uname;
                arr.push({
                    elem:c,
                    innerHTML:"{{uname}}"
                });
            }else if(c.innerHTML=="{{score}}"){
                c.innerHTML==data.score;
                arr.push({
                    elem:c,
                    innerHTML:"{{score}}"
                })
            }
        }
    }
};
//至少扫描一次
getChildren(nav);

//响应系统
Object.defineProperties(data,{
    _uname:{
        value:data.uname,
        writable:true,
        enumerable:false
    },
    uname:{
        get(){return this._uname},
        set(value){
            this._uname=value;
            for(var obj of arr){
                if(obj.innerHTML=="{{uname}}"){
                    obj.elem.innerHTML=value;
                }
            }
        }
    },
    _score:{
        value:data.score,
        writable:true,
        enumerable:false
    },
    score:{
        get(){return this._score},
        set(value){
            this._score=value;
            for(var obj of arr){
                if(obj.innerHTML=="{{score}}"){
                    obj.elem.innerHTML=value;
                }
            }
        }
    },
    enumerable:true
})
Object.seal(data);
```

## 7.模仿vue实现简单的MVVM

## 8.实现字符串反转几种方法

### 答案：
- 1.for循环
```
var arr=str.split('');
var newArr=[];
for(var i=0;i<arr.length;i++){
    newArr[i]=arr[arr.length-i-1];
}
var newStr=newArr.join('')
console.log(str0);
```
- 2.charAt
```
var newStr='';
for(var i=0;i<str.length;i++){
    newStr+=str.charAt(str.length-i-1);
}
console.log(newStr);
```
- 3.reverse()函数
```
var newStr=str.split("").reverse().join("");
console.log(newStr);
```
- 4.Set集合 对象
```
var arr=str.split('');
var obj=Array.from(new Set([...arr]));
var newStr='';
for(i of obj){
    newStr+=obj[arr.length-i];
}
console.log(newStr)
```
- 5.pop()和push()
```
var arr=str.split('');
var newArr=[];
while(arr.length>0){
    newArr.push(arr.pop())
};
var newStr=newArr.join("");
console.log(newStr)
```

## 9.数组去重的几种方法

### 答案：
- 1.Set ES6
```
var newArr=Array.from(new Set(arr));
console.log(newArr);
```
- 2.for ES5
```
for(var i=0;i<arr.length;i++){
    for(j=i+1;j<arr.length;j++){
        if(arr[i]==arr[j]){
            arr.splice(j,1);
            j--;
        }
    }
}
console.log(arr);
```
- 3.indexOf
```
var newArr=[];
for(var i=0;i<arr.length;i++){
    if(newArr.indexOf(arr[i])===-1){
        newArr.push(arr[i])
    }
}
console.log(newArr);
```
- 4.sort()
```
var arr=arr.sort();
var newArr=[arr[0]];
for(var i=1;i<arr.length;i++){
    if(arr[i]!==arr[i-1]){
        newArr.push(arr[i])
    }
}
console.log(newArr);
```
- 5.对象属性 存在问题，纯数字可以用
```
var newArr=[];
var obj={};
for(var i=0;i<arr.length;i++){
    if(!obj[arr[i]]){
        newArr.push(arr[i]);
        obj[arr[i]]=1
    }else{
        obj[arr[i]]++
    }
}
console.log(newArr);
```
- 6.includes
```
var newArr=[];
for(var i=0;i<arr.length;i++){
    if(!newArr.includes(arr[i])){//检测数组是否有某个值
        newArr.push(arr[i]);
    }
}
console.log(newArr);
```
- 7.hasOwnProperty和filter
```
var obj={};
var newArr=arr.filter((item,index,arr)=>{
    return obj.hasOwnProperty(typeof item+item)?false:(obj[typeof item+item]=true)
})
console.log(arrM6);
```
- 8.递归
```
arr.sort(function(a,b){
    return a-b;
})
function loop(index){
    if(index>=1){
        if(arr[index]===arr[index-1]){
            arr.splice(index,1);
        }
        loop(index-1)
    }
}
loop(arr.length-1);
console.log(arr);
```
- 9.Map数据结构
```
var map=new Map();
var newArr=[];
for(var i=0;i<arr.length;i++){
    if(map.has(arr[i])){
        map.set(arr[i],true);
    }else{
        map.set(arr[i],false);
        newArr.push(arr[i]);
    }
}
console.log(newArr);
```
- 10.reduce+includes
```
arr=arr.reduce((prev,cur)=>prev.includes(cur)?prev:[...prev,cur],[]);
console.log(arr);
```
- 11.[...new Set(arr)]
```
var newArr=[...new Set(arr)];
console.log(newArr);
```

## 10.去掉"get-element-by-id"中"-"并转为驼峰

### 答案：
```
function camelCase(str){
    var arr=str.split('-');
    var Arr=[];
    for(var i=0;i<arr.length;i++){
            var strArr=arr[i].split('');
            if(i==0){
                strArr[0]=strArr[0]
            }else{
            strArr[0]=strArr[0].toUpperCase();
            }
            Arr.push(...strArr);
    }
    var newStr=Arr.join("");
    return newStr;   
}
```

## 11.es6的新特性有哪儿些？

### 答案：
- let 和 const
- Set 和 Map数据结构
- Class
- 模板字符串
- 箭头函数
- Itertor 和 for of 遍历索引数组和类数组对象 
- ... 参数增强和打散数组
- 解构 数组/对象/参数
- Promise
- Symbol 基本类型
- Reflect
- Proxy
- Decorator 装饰器
- es6 module es6模块

## 12.h5新特性有哪些?

### 答案：
- 语义化标签
- input表单类型增加 color date email search url tel number range month week
- 音频和视频
- canvas
- svg
- geolocation 地理定位
- drag&drop 拖放
- WebWorker Worker线程 PWA应用
- WebStorage 存储
- WebSocket 全双工通信 
- classlist
- fileReader
- Server-Sent Events(sse) 单向消息传递
- Application Cache 离线缓存
- Web SQL
- MathML 数学标记 基于xml ```<math xmlns="http://www.w3.org/1998/Math/MathML"></math>```

## 13.谈谈你对闭包的理解

### 答案：
- 闭包是函数和声明该函数的词法环境的组合。(MDN定义)
A clousure is the combination of a function and the lexical environment within which that function was declared.
注：离散数学中是对集合间关系的一种描述
- ECMAScript支持闭包，因而js中的闭包表现为：外层函数调用后，外层函数变量被内层函数对象的[[scope]]引用着而导致外层函数的作用域对象AO无法释放(垃圾回收));
- js中闭包常见作用：<1>.实现共有变量，如：函数累加器;<2>.可以做缓存(存储结构);<3>.属性私有化;<4>.模块化开发，防止污染全局变量
- js闭包的缺点：比普通函数占有更多内存(多的是外层函数作用域对象AO始终存在),容易造成内存泄漏

## 14.一个页面从输入url到页面加载显示完成，发生了什么？

### 答案：
1.浏览器通过DNS将url地址解析为ip(如果有缓存直接返回缓存，否则递归解析)
2.通过DNS解析得到了目标服务器的ip地址后，与服务器建立TCP连接。
    - ip协议：选择传输路线，负责找到
    - tcp协议：三次握手，分片，可靠传输，重新发送的机制
3.浏览器通过http协议发送请求(增加http的报文信息)头 体 行
4.服务器接收请求后，查库，读文件，拼接好返回的http响应
5.浏览器收到html，开始渲染
6.解析html为dom，解析css为css-tree，最终生成render-tree阻塞渲染
7.遍历渲染树开始布局，计算每个节点的位置大小信息
8.将渲染树每个节点绘制到屏幕
9.加载js文件，运行js脚本
10.relow(样式)和repaint(位置)

## 15.简述同步和异步的区别？

### 答案：
- 在通信中，同步和异步强调的是消息的通信机制；而在计算机操作系统中，复用了通信里的概念，同步(Synchronous)是指在发生一个调用时，在没有得到结果之前，该调用不返回；异步(Asynchronous)是指在发生一个调用时，立即返回。

## 16.px、em、rem的区别？

### 答案：
- 三者都是制作web网页时用到的单位
- px是实际像素大小，em是相对于父元素的像素大小，rem是相对于跟玉原石的像素大小
- IE6~8不支持em和rem属性

## 17.水平垂直居中的方法有哪些？

### 答案：

## 18.验证邮箱格式

### 答案：
``` /^(\w)+(\.\w+)*@(\w)+((\.\w{2,3}){1,3})$/ ```

## 19.手写简版koa源码

### 答案：

## 20.减少页面加载时间的方法

### 答案：
- 重复的HTTP请求数量应尽量减少
- 压缩Javascript、CSS代码
- 在文件头部放置css样式的定义
- 在文件末尾放Javascript脚本
- css、javascript改由外部调用，避免重复调用
- 尽可能减少DOM元素
- 避免使用CSS Expressions
- 添加文件过期或缓存头
- 使用CDN(Content Delivery Network)网络加速
- 服务器启用gzip压缩功能
- Ajax采用缓存调用
- 如果可以，Ajax调用尽量采用GET方法调用(其他方法会发送两次请求，一次option，一次为正常请求)
- 缩减iframe的使用，如无必要，尽量不要使用
- 合理使用Flush(后端)
- 避免采用301、302转向
- 优化图片文件
- 采用分页或翻页后展示
- 使用多域名负载网页内的多个文件、图片

## 21.请写出你所知道的display属性的值

### 答案：
- display:none 此元素不会被显示
- display:block 此元素将显示为块级元素，此元素前后会带有换行符
- display:inline 此元素会被显示为内联元素，元素前后没有换行符
- display:inline-block 行内块元素，css2.1新增
- display:list-item 此元素会作为列表显示
- display:run-in 此元素会根据上下文作为块级元素或内两元素显示
- display:compact css2.1废除
- display:marker css2.1废除
- display:table 此元素会作为块级表格来显示，表格前后带有换行符
- display:inline-table 此元素会作为内联表格来显示，表格前后没有换行符
- display:table-row-group 此元素会作为一个或多个行的分组来显示(类似<tbody>)
- display:table-header-group 此元素会作为一个或多个行的分组来显示(类似<thead>)
- display:table-footer-group 此元素会作为一个或多个行的分组来显示(类似<tfoot>)
- display:table-row 此元素会作为一个表格行来显示(类似<tr>)
- display:table-column-group 此元素会作为一个或多个列的分组来显示(类似<colgroup>)
- display:table-column 此元素会作为一个单元格列显示(类似<col>)
- display:table-cell 此元素会作为一个表格单元格来显示(类似<td>和<th>)
- display:table-caption 此元素会作为一个表格标题来显示(类似<caption>)
- display:inherit 规定应该从父元素继承display属性的值
- 410598979

