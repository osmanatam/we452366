# 编程题

## 方法库部分

### 实现防抖函数(debounce)
```
    const debounce = (fn, delay) => {
        let timer = null;
        return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => {
                fn.apply(this, args);
            }, delay);
        };
    };
```

### 实现节流函数(throttle)
```
    const throttle = (fn, delay = 500) => {
        let flag = true;
        return (...args) => {
            if (!flag) return;
            flag = false;
            setTimeout(() => {
                fn.apply(this, args);
                flag = true;
            }, delay);
        };
    };
```

### 实现lazy-load懒加载
```
    let imgs=document.querySelectorAll('img');
    let clientHeight=window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
    function lazyLoad(){
        let scrollTop=window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
        for(let i=0;i<imgs.length;i++){
            let x=clientHeight + scrollTop-imgs[i].offsetTop;
            if(x>0 && x<clientHeight+imgs[i].height){
                imgs[i].src=imgs[i].getAttribute('data')
            }
        }
    }
```

### 实现拖拽
```
    window.onload=function(){
        let drag=document.getElementById('box');
        drag.onmousedown=function(e){
            let e = e || window.event;
            let diffX=e.clientX-drag.offsetLeft;
            let diffY=e.clientY-drag.offsetTop;
            drag.onmousemove=function(e){
                let left=e.clientX-diffX;
                let top=e.clientY-diffY;
                if(left<0){
                    left=0;
                }else if(left>window.innerWidth-drag.offsetWidth){
                    left=window.innerWidth-drag.offsetWidth;
                }
                if(top<0){
                    top=0;
                }else if(top>window.innerHeight-drag.offsetHeight){
                    top=window.innerHeight-drag.offsetHeight
                }
                drag.style.left=left+'px';
                drag.style.top=top+'px';
            }
            drag.onmouseup=function(e){
                this.onmousemove=null;
                this.onmouseup=null;
            }
        }
    }
```

### 实现基于Promise的ajax函数
```
    function ajax(url,method,fn,type){
        return new Promise((resolve,reject)=>{
                var xhr=new XMLHttpRequest();
                xhr.onreadystatechange=function(){
                    if(xhr.readyState==4){
                        if(xhr.status==200){
                            //var result=xhr.responseText;
                            //fn(result);
                            resolve(JSON.parse(xhr.responseText).count);
                        }	
                    }
                };

                xhr.open(method,url+"?"+type,true);

                if(method=="post"){
                    xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
                }

                if(method=="get"){
                    xhr.send(null);
                }else if(method=="post"){
                    xhr.send(type);
                }

            }
        )	
    }
```

### 实现一个深克隆(deepclone)
```
    const clone = parent => {
        const isType = (obj, type) => {
            if (typeof obj !== "object") return false;
            const typeString = Object.prototype.toString.call(obj);
            let flag;
            switch (type) {
                case "Array":
                    flag = typeString === "[object Array]";
                    break;
                case "Date":
                    flag = typeString === "[object Date]";
                    break;
                case "RegExp":
                    flag = typeString === "[object RegExp]";
                    break;
                default:
                    flag = false;
            }
            return flag;
        };

        const getRegExp = re => {
            var flags = "";
            if (re.global) flags += "g";
            if (re.ignoreCase) flags += "i";
            if (re.multiline) flags += "m";
            return flags;
        };

        const parents = [];
        const children = [];

        const _clone = parent => {
            if (parent === null) return null;
            if (typeof parent !== "object") return parent;

            let child, proto;

            if (isType(parent, "Array")) {
                child = [];
            } else if (isType(parent, "RegExp")) {
                child = new RegExp(parent.source, getRegExp(parent));
                if (parent.lastIndex) child.lastIndex = parent.lastIndex;
            } else if (isType(parent, "Date")) {
                child = new Date(parent.getTime());
            } else {
                proto = Object.getPrototypeOf(parent);
                child = Object.create(proto);
            }

            const index = parents.indexOf(parent);

            if (index != -1) {
                return children[index];
            }
            parents.push(parent);
            children.push(child);

            for (let i in parent) {
                child[i] = _clone(parent[i]);
            }
            return child;
        };

        return _clone(parent);
    };
```

### 解析URL Params为对象
```
    function parseParam(url) {
        const paramsStr = /.+\?(.+)$/.exec(url)[1]; 
        const paramsArr = paramsStr.split('&'); 
        let paramsObj = {};
        paramsArr.forEach(param => {
            if (/=/.test(param)) { 
                let [key, val] = param.split('='); 
                val = decodeURIComponent(val); 
                val = /^\d+$/.test(val) ? parseFloat(val) : val; 

                if (paramsObj.hasOwnProperty(key)) { 
                    paramsObj[key] = [].concat(paramsObj[key], val);
                } else { 
                    paramsObj[key] = val;
                }
            } else { 
                paramsObj[param] = true;
            }
        })
        return paramsObj;
    }
```

### 查找字符串中出现最多的字符和个数
```
    let str = "abcabcabcbbccccc";
    let num = 0;
    let char = '';

    str = str.split('').sort().join('');

    let re = /(\w)\1+/g;
    str.replace(re,($0,$1) => {
        if(num < $0.length){
            num = $0.length;
            char = $1;        
        }
    });
    console.log(`字符最多的是${char}，出现了${num}次`);
```

### 字符串查找
```
    a='34';b='1234567'; // 返回 2
    a='35';b='1234567'; // 返回 -1
    a='355';b='12354355'; // 返回 5
    isContain(a,b);
    function isContain(a, b) {
        for (let i in b) {
            if (a[0] === b[i]) {
                let tmp = true;
                for (let j in a) {
                    if (a[j] !== b[~~i + ~~j]) {
                    tmp = false;
                    }
                }
                if (tmp) {
                    return i;
                }
            }
        }
        return -1;
    }
```

### 实现字符串翻转

```
    var arr=str.split('');
    var newArr=[];
    for(var i=0;i<arr.length;i++){
        newArr[i]=arr[arr.length-i-1];
    }
    var newStr=newArr.join('')
    console.log(str0);
```

```
    var newStr='';
    for(var i=0;i<str.length;i++){
        newStr+=str.charAt(str.length-i-1);
    }
    console.log(newStr);
```

```
    var newStr=str.split("").reverse().join("");
    console.log(newStr);
```

```
    var arr=str.split('');
    var obj=Array.from(new Set([...arr]));
    var newStr='';
    for(i of obj){
        newStr+=obj[arr.length-i];
    }
    console.log(newStr)
```

```
    var arr=str.split('');
    var newArr=[];
    while(arr.length>0){
        newArr.push(arr.pop())
    };
    var newStr=newArr.join("");
    console.log(newStr)
```

### 实现数组去重

```
    var newArr=Array.from(new Set(arr));
    console.log(newArr);
```

```
    for(var i=0;i<arr.length;i++){
        for(j=i+1;j<arr.length;j++){
            if(arr[i]==arr[j]){
                arr.splice(j,1);
                j--;
            }
        }
    }
    console.log(arr);
```

```
    var newArr=[];
    for(var i=0;i<arr.length;i++){
        if(newArr.indexOf(arr[i])===-1){
            newArr.push(arr[i])
        }
    }
    console.log(newArr);
```

```
    var arr=arr.sort();
    var newArr=[arr[0]];
    for(var i=1;i<arr.length;i++){
        if(arr[i]!==arr[i-1]){
            newArr.push(arr[i])
        }
    }
    console.log(newArr);
```

```
    var newArr=[];
    var obj={};
    for(var i=0;i<arr.length;i++){
        if(!obj[arr[i]]){
            newArr.push(arr[i]);
            obj[arr[i]]=1
        }else{
            obj[arr[i]]++
        }
    }
    console.log(newArr);
```

```
    var newArr=[];
    for(var i=0;i<arr.length;i++){
        if(!newArr.includes(arr[i])){//检测数组是否有某个值
            newArr.push(arr[i]);
        }
    }
    console.log(newArr);
```

```
    var obj={};
    var newArr=arr.filter((item,index,arr)=>{
        return obj.hasOwnProperty(typeof item+item)?false:(obj[typeof item+item]=true)
    })
    console.log(arrM6);
```

```
    arr.sort(function(a,b){
        return a-b;
    })
    function loop(index){
        if(index>=1){
            if(arr[index]===arr[index-1]){
                arr.splice(index,1);
            }
            loop(index-1)
        }
    }
    loop(arr.length-1);
    console.log(arr);
```

```
    var map=new Map();
    var newArr=[];
    for(var i=0;i<arr.length;i++){
        if(map.has(arr[i])){
            map.set(arr[i],true);
        }else{
            map.set(arr[i],false);
            newArr.push(arr[i]);
        }
    }
    console.log(newArr);
```

```
    arr=arr.reduce((prev,cur)=>prev.includes(cur)?prev:[...prev,cur],[]);
    console.log(arr);
    ```

    ```
    var newArr=[...new Set(arr)];
    console.log(newArr);
```

### 实现旋转数组
```
```

### 实现千位分隔符
```
    function parseToMoney(num) {
        num = parseFloat(num.toFixed(3));
        let [integer, decimal] = String.prototype.split.call(num, '.');
        integer = integer.replace(/\d(?=(\d{3})+$)/g, '$&,');
        return integer + '.' + (decimal ? decimal : '');
    }
```

```
    function parseToMoney(str){
        let re = /(?=(?!\b)(\d{3})+$)/g; 
        return str.replace(re,','); 
    }
```

### 判断是否是电话号码
```
    function isPhone(tel) {
        var regx = /^1[34578]\d{9}$/;
        return regx.test(tel);
    }
```

### 验证是否是邮箱
```
    function isEmail(email) {
        var regx = /^([a-zA-Z0-9_\-])+@([a-zA-Z0-9_\-])+(\.[a-zA-Z0-9_\-])+$/;
        return regx.test(email);
    }
```

### 验证是否是身份证
```
    function isCardNo(number) {
        var regx = /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/;
        return regx.test(number);
    }
```

### 实现一个函数柯里化
```
```

### 实现一个函数反柯里化
```
```

### 实现数组扁平化
```
```

### 实现回文数
```
```

### 实现isArray()方法 判断是否为数组
```
```

### 实现isContain()方法，判断是否包含该字符串
```
    function isContain(a, b) {
        for (let i in b) {
            if (a[0] === b[i]) {
            let tmp = true;
            for (let j in a) {
                if (a[j] !== b[~~i + ~~j]) {
                tmp = false;
                }
            }
            if (tmp) {
                return i;
            }
            }
        }
        return -1;
    }
```


## 原理部分

### 实现Event(event bus)
```
    class EventEmitter {
        constructor() {
            this._events = this._events || new Map(); 
            this._maxListeners = this._maxListeners || 10; 
        }
    }

    EventEmitter.prototype.emit = function(type, ...args) {
        let handler;
        handler = this._events.get(type);
        if (args.length > 0) {
            handler.apply(this, args);
        } else {
            handler.call(this);
        }
        return true;
    };

    EventEmitter.prototype.addListener = function(type, fn) {
        if (!this._events.get(type)) {
            this._events.set(type, fn);
        }
    };

    EventEmitter.prototype.emit = function(type, ...args) {
        let handler;
        handler = this._events.get(type);
        if (Array.isArray(handler)) {
            for (let i = 0; i < handler.length; i++) {
                if (args.length > 0) {
                    handler[i].apply(this, args);
                } else {
                    handler[i].call(this);
                }
            }
        } else {
            if (args.length > 0) {
                handler.apply(this, args);
            } else {
                handler.call(this);
            }
        }
        return true;
    };

    EventEmitter.prototype.addListener = function(type, fn) {
        const handler = this._events.get(type); 
        if (!handler) {
            this._events.set(type, fn);
        } else if (handler && typeof handler === "function") {
            this._events.set(type, [handler, fn]); 
        } else {
            handler.push(fn); 
        }
    };

    EventEmitter.prototype.removeListener = function(type, fn) {
        const handler = this._events.get(type); 

        if (handler && typeof handler === "function") {
            this._events.delete(type, fn);
        } else {
            let position;
            for (let i = 0; i < handler.length; i++) {
                if (handler[i] === fn) {
                    position = i;
                } else {
                    position = -1;
                }
            }

            if (position !== -1) {
                handler.splice(position, 1);
                if (handler.length === 1) {
                    this._events.set(type, handler[0]);
                }
            } else {
                return this;
            }
        }
    };
```

### 实现instanceOf
```
    function instance_of(L, R) {
        var O = R.prototype; 
        L = L.__proto__; 
        while (true) {
            if (L === null) return false;
            if (O === L)
            return true;
            L = L.__proto__;
        }
    }
```

### 实现一个new
```
    function objectFactory() {
        const obj = new Object();
        const Constructor = [].shift.call(arguments);

        obj.__proto__ = Constructor.prototype;

        const ret = Constructor.apply(obj, arguments);

        return typeof ret === "object" ? ret : obj;
    }
```

### 实现一个call
```
    Function.prototype.myCall = function(context) {
        context.fn = this;
        let args = [];
        for (let i = 1, len = arguments.length; i < len; i++) {
            args.push(arguments[i]);
        }
        context.fn(...args);
        let result = context.fn(...args);
        delete context.fn;
        return result;
    };
```

### 实现一个apply
```
    Function.prototype.myapply = function(context, arr) {
        var context = Object(context) || window;
        context.fn = this;

        var result;
        if (!arr) {
            result = context.fn();
        } else {
            var args = [];
            for (var i = 0, len = arr.length; i < len; i++) {
                args.push("arr[" + i + "]");
            }
            result = eval("context.fn(" + args + ")");
        }

        delete context.fn;
        return result;
    };
```

### 实现bind
```
    if (!Function.prototype.bind) {
        Function.prototype.bind = function(oThis) {
            if (typeof this !== 'function') {
                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
            }

            var aArgs   = Array.prototype.slice.call(arguments, 1),
                fToBind = this,
                fNOP    = function() {},
                fBound  = function() {
                return fToBind.apply(this instanceof fBound
                        ? this
                        : oThis,
                        aArgs.concat(Array.prototype.slice.call(arguments)));
                };

            if (this.prototype) {
                fNOP.prototype = this.prototype; 
            }

            fBound.prototype = new fNOP();

            return fBound;
        };
    }
```

### 实现Object.create()
```
    function create(proto) {
        function F() {}
        F.prototype = proto;
        return new F();
    }
```

### 实现类的继承
```
    function Parent(name) {
        this.parent = name
    }
    Parent.prototype.say = function() {
        console.log(`${this.parent}: 你打篮球的样子像kunkun`)
    }
    function Child(name, parent) {
        Parent.call(this, parent)
        this.child = name
    }

    Child.prototype = Object.create(Parent.prototype);
    Child.prototype.say = function() {
        console.log(`${this.parent}好，我是练习时长两年半的${this.child}`);
    }

    Child.prototype.constructor = Child;

    var parent = new Parent('father');
    parent.say();

    var child = new Child('cxk', 'father');
    child.say();
```

### 实现rem原理
```
    function setRem(){
        let doc=document.documentElement;
        let width=doc.getBoundingClientRect().width;
        let rem=width/75;
        doc.style.fontSize=rem+'px'
    }
    addEventListener('resize',setRem)
```

### 实现一个双向数据绑定
```
    let arrayProto=Array.prototype;
    let proto=Object.create(arrayProto);
    ['push','unshift','splice','reverse','sort','shift','pop'].forEach(method=>{
        proto[method]=function(...args){
            let inserted;
            switch(method){
                case 'push':
                case 'unshift':
                    inserted=args
                    break;
                case 'splice':
                    inserted = args.slice(2);
                default:
                    break;
            }
            ArrayObserver(inserted);
            arrayProto[method].call(this,...args)
        }
    })
    function ArrayObserver(obj){
        for(let i=0;i<obj.length;i++){
            let item=obj[i];
            observer(item);
        }
    }
    function observer(obj){
        if(typeof obj !== 'object' || obj == null){
            return obj;
        }
        if(Array.isArray(obj)){
            Object.setPrototypeOf(obj,proto)
            ArrayObserver(obj);
        }else{
            for (let key in obj){
                defineReactive(obj,key,obj[key])
            }
        }
    }
    function defineReactive(obj,key,value){
        observer(value); // 递归创建
        get(){
            return value;
        },
        set(newValue){
            if(value!==newValue){
                observer(newValue);
                value=newValue;
            }
        }
    }
```

### 实现Vuex
```
```

### 实现一个简单路由
```
    class Route{
        constructor(){
            this.routes={};
            this.currentHash='';
            this.freshRoute=this.freshRoute.bind(this);
            window.addEventListener('load',this.freshRoute,false);
            window.addEventListener('hashchange',this.freshRoute,false);
        }
        storeRoute(path,cb){
            this.routes[path]=cb || function(){}
        }
        freshRoute(){
            this.currentHash=location.hash.slice(1) || '/';
            this.routes[this.currentHash]()
        }
    }
```

### 实现Promise
```
```

### 使用setTimeout实现setInterval
```
    setTimeout(function(){
        setTimeout(arguments.callee,500)
    },500)
```

### 实现JSON.parse
```
    var json = '{"name":"cxk", "age":25}';
    var obj = eval("(" + json + ")");
```

### 实现JSON.stringify
```
```

### 实现indexOf方法
```
    function indexOf(arr,elem,fromi){
        fromi=fromi||0;
        for(var i=fromi;i<arr.length;i++){
            if(elem===arr[i]){
                return i;
            }
        }
    return -1;
    }
```

### 实现reduce方法
```
```

### 实现trim方法
```
    function trim(str){
        if(str && typeof str==='string'){
            return str.replace(/^\s+l\s+$/g/,'')
        }
    }
```

### 实现一个模板引擎 
```
    function render(template, data) {
        const reg = /\{\{(\w+)\}\}/; 
        if (reg.test(template)) { 
            const name = reg.exec(template)[1]; 
            template = template.replace(reg, data[name]); 
            return render(template, data); 
        }
        return template; 
    }
```

### 实现一个转驼峰方法camelCase
```
    function camelCase(str){
        return str.replace(/-\w/g,function(newStr){
            return newStr.slice(1).toUpperCase();
        })
    }
```

### 实现Virtual Dom && Diff
```
```


## 算法部分

### 实现冒泡排序
```
    function swap(A,i,j){
        const t=A[i];
        A[i]=A[j];
        A[j]=t;
    }
    function buble_sort(A){
        // |---未排序---|---已排序的最大值---|
        // 初始 |------未排序------|i|
        for(let i=A.length;i>0;i--){
            for(let j=1;j<i;j++){
                if(A[j]<A[j-1]){
                    swap(A,j,j-1)
                }
            }
            // 循环不变式成立
        }
        return A
    }
```

### 实现快速排序
```
    // i指向最后一个小于支点的数字，j指向未确认的下一个数字 初始值 i=-1,j=0
    function swap(A,i,j){
        [A[i],A[j]]=[A[j],A[i]];
    }

    function divide(A,p,r){
        const x=A[r-1];
        let i=p-1;
        for(let j=p;j<r-1;j++){
            if(A[j]<x){
                i++;
                swap(A,i,j);
            }
        }
        swap(A,i+1,r-1);
        return i+1;
    }

    function quick_sort(A,p=0,r){
        r = typeof r !== 'undefined' ? r : A.length;
        if(p<r-1){
            const q=divide(A,p,r);
            quick_sort(A,p,q);
            quick_sort(A,q+1,r)
        }
    }
```

### 实现插入排序
```
    function insert_sort(A){
        for(
            let j=1;                    
            j<A.length;                 
            j++){                       
            const key=A[j];             
            let i=j-1;                  
            while(i>=0 && A[i]>key){    
                A[i+1]=A[i];            
                i--;                    
            }
            A[i+1]=key                  
        }
    }
```

### 实现归并排序
```
    const SENTINEL=Number.MAX_SAFE_INTEGER;

    function divide(p,r){
        return Math.floor((p+r)/2)
    }

    function conquer(A,p,q,r){
        const A1=A.slice(p,q);
        const A2=A.slice(q,r);

        A1.push(SENTINEL);
        A2.push(SENTINEL);

        for(let k=p,i=0,j=0;k<r;k++){
            A[k]=A1[i]<A2[i]?A1[i++]:A2[j++]
        }
    }

    function merge_sort(A,p=0,r){
        r=r || A.length;
        if(r-p===1){return}
        if(r-p===2){
            if(A[p]>A[r-1]){
                [A[p],A[r-1]]=[A[r-1],A[p]]
            }
            return
        }

        const q=divide(p,r);
        console.log('divide:'+q);
        merge_sort(A,p,q)
        merge_sort(A,q,r)
        conquer(A,p,q,r)
    }
```

### 实现红黑树
```
```

## 综合部分

### 实现convert方法，将原始list转换成树形结构
```
```

### 实现一个无缝轮播图
- html部分
```
    <div class="container" id="container">
        <div id="btn-prev" class="btn-ctrl">&lt;</div>
        <div id="btn-next" class="btn-ctrl">&gt;</div>
        <ul id="inner-list">
            <li><img src="images/head1.jpeg" alt=""/></li>
            <li><img src="images/head2.jpeg" alt=""/></li>
            <li><img src="images/head3.jpeg" alt=""/></li>
        </ul>
        <ul id="dot-list">
           
        </ul>
    </div>
```
- js部分
```
window.onload = function(){
    var eleInners = document.getElementById('inner-list'),
        eleDots = document.getElementById('dot-list'),
        liImgs = eleInners.getElementsByTagName('li'),
        liDots = eleDots.children,
        elePrev = document.getElementById('btn-prev'),
        eleNext = document.getElementById('btn-next'),
        LI_WIDTH = liImgs[0].offsetWidth,
        TIME_DURATION = 3000,
        interval = null,
        index = 0,
        circle = 0;
    eleInners.appendChild(liImgs[0].cloneNode(true));

    for(var i= 0,len = liImgs.length -1;i<len;i++){
        var li = document.createElement('li');
        li.innerHTML = i+1;
        eleDots.appendChild(li)
    };

    liDots[0].className = 'cur';

    function animate(obj,targetPlace){
        clearInterval(obj.timer);
        obj.timer = setInterval(function(){
            var speed = obj.offsetLeft > targetPlace ? -15:15;
            var result = targetPlace - obj.offsetLeft;
            
            if(Math.abs(result) > Math.abs(speed)){
                obj.style.left = obj.offsetLeft + speed +'px'
            }else{
                obj.style.left = targetPlace+'px';
                clearInterval(obj.timer);
            }
        },10)
    }

    interval = setInterval(autoplay,3000)

    function autoplay(){
        index++;
        
        if(index > liImgs.length -1){
            eleInners.style.left = 0;
            index = 1;
        }

        animate(eleInners, -index * LI_WIDTH);
        circle++;

        if(circle >= liImgs.length -1){
            circle = 0;
        }
        
        for(var i= 0,len = liDots.length;i<len;i++){
            liDots[i].className ='';
        }

        liDots[circle].className = 'cur';
    }

    function moveright(){
        index--;

        if(index <0){
            eleInners.style.left = -(liImgs.length -2)* LI_WIDTH + 'px';
            index = liImgs.length -2;
        }
        
        animate(eleInners, -index * LI_WIDTH);
        
        circle --;

        if(circle < 0){
            circle = liImgs.length - 2;//circle回到最后一个点
        }

        for(var i= 0,len = liDots.length;i<len;i++){
            liDots[i].className ='';
        }

        liDots[circle].className = 'cur'
    }

    eleInners.addEventListener('mouseenter',function(event){
        clearInterval(interval)
    });

    eleInners.addEventListener('mouseleave',function(event){
        interval = setInterval(autoplay,3000)
    });

    eleDots.addEventListener('click',function(event){
        clearInterval(interval);
        var target = event.target;
        var currentTarget = event.currentTarget;
        index = target.innerHTML - 0 - 1;
        circle = index ;

        for(var i= 0,len = liDots.length;i<len;i++){
            liDots[i].className ='';
        }

        liDots[circle].className = 'cur';
        animate(eleInners, - index * LI_WIDTH);
    })

    elePrev.addEventListener('click',function(event){
        clearInterval(interval)
        moveright();
        interval = setInterval(autoplay,3000)
    })

    eleNext.addEventListener('click',function(event){
        clearInterval(interval);
        autoplay();
        interval = setInterval(autoplay,3000);
    })
}
```

### 写一个幻灯片（css加分）
- html部分：
```
    <div class="myDiv"></div>
```
- css部分：
```
    .myDiv{
        width: 600px;
        height: 400px;
        margin: 20px auto;
        background-size: over;
        background-position: center;
        animation-name:loop;
        animation-duration: 20s;
        animation-iteration-count: infinite;
    }
    @keyframes loop{
        0% {background: url('图片1.jpg') no-repeat;}
        25% {background: url('图片2.jpg') no-repeat;}
        50% {background: url('图片3.jpg') no-repeat;}
        75% {background: url('图片4.jpg') no-repeat;}
        100% {background: url('图片5.jpg') no-repeat;}
    }
```

### 绘制一个等腰三角形
- html部分：
```
    <canvas id="canvas" width="300px" height="300px"></canvas>
```
- script部分：
```
    let ctx=document.getElementById('canvas').getContext('2d');
    ctx.beginPath();
    ctx.moveTo(0,150);
    ctx.lineTo(150,0);
    ctx.lineTo(300,150);
    ctx.closePath();
    ctx.strokeStyle='#666';
    ctx.lineWidth=3;
    ctx.stroke();
```

### 用JavaScript实现斐波那契数列函数，返回第n个斐波那切数。f(1)=1,f(2)=2等
```
    function* fibonacci() {
        let [prev, curr] = [1, 1];
            while (true) {
            [prev, curr] = [curr, prev + curr];
            yield curr;
        }
    }
    function Fibonacci(n){
        if (n===1 || n===2) {
                return 1;
            }
        let ac = 0;
        const fibo = fibonacci();
        for (let i = 2;i < n; i++) {
        ac = fibo.next()
        }
        return ac.value;
    }
```

### 删除数组arr第一个元素。不要直接修改数组arr，结果返回新的数组。

```
    function insert(arr, item, index) {
        return arr.slice(0,index).concat(item,arr.slice(index));
    }
```

```
    function insert(arr, item, index) {
        var newArr=arr.concat();
        newArr.splice(index,0,item);
        return newArr;
    }
```

```
    function insert(arr, item, index) {
        var newArr=arr.slice(0);
        newArr.splice(index,0,item);
        return newArr;
    }
```

```
    function insert(arr, item, index) {
        var newArr=[];
        [].push.apply(newArr, arr);
        newArr.splice(index,0,item);
        return newArr;
    }
```

### 实现一个打点计时器，要求：(1)从start到end（包含start和end），每隔100毫秒console.log一个数字，每次数字增幅为1；(2)返回的对象中需要包含一个cancel方法，用于停止定时操作；(3)第一个数需要立即输出
```
    function count(start, end) {
        console.log(start)
        var timer = setInterval(
            function(){
                if(start<end) console.log(start+=1);
            },100)
        return {cancel:function(){clearInterval(timer)}}
    }
```

### sort方法将数组内的对象进行排序
```
    function compare(propertyName, index) {
        return function(a, b) {
            let value1 = a[propertyName];
            let value2 = b[propertyName];
            if (vm.reverse[index]) {
                return value2 - value1;
            } else {
                return value1 - value2;
            }
        };
    }
```

### 查找字符串中出现最多的字符和个数
```
    let num=0;
    let char='';

    let str = str.split('').sort().join('');
    str.replace(/(\w)\1+/g,($0,$1) => {
        if(num < $0.length){
            num = $0.length;
            char = $1;        
        }
    });
    console.log(`字符最多的是${char}，出现了${num}次`);
```

### 实现一个方法，随机打乱一个数组
```
    function shuffle_simple(arr){
        return arr.sort(()=>Math.random()- .5)
    }
```
或
```
    function fisher_yates_shuffle(arr){
        for(let i=0;i<arr.length-1;i++){
            const j=i+Math.floor(Math.random()*(arr.length-1));
            [arr[i],[arr[j]]]=[arr[j],arr[i]]
        }
        return arr
    }
```
或
```
    function shuffle(arr){
        const m=[];
        const N=arr.length*arr.length*arr.length;
        for(let i=0;i<arr.length-1;i++){
            m[i]=Math.floor(Math.random(1,N))
        }
        return arr.sort((i,j)=>m[i]-m[j])
    }
```
