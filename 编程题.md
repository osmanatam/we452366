# 编程题

## 方法库部分

### 实现防抖函数(debounce)
```
    const debounce = (fn, delay) => {
        let timer = null;
        return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => {
                fn.apply(this, args);
            }, delay);
        };
    };
```
underscore版本:
```
    _.debounce = function(func, wait, immediate) {
        var timeout, result;

        var later = function(context, args) {
        timeout = null;
        if (args) result = func.apply(context, args);
        };

        var debounced = restArguments(function(args) {
        if (timeout) clearTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(later, wait);
            if (callNow) result = func.apply(this, args);
        } else {
            timeout = _.delay(later, wait, this, args);
        }

        return result;
        });

        debounced.cancel = function() {
        clearTimeout(timeout);
        timeout = null;
        };

        return debounced;
    };
```
lodash版本
```
    import isObject from './isObject.js'
    import root from './.internal/root.js'
    function debounce(func, wait, options) {
        let lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime

        let lastInvokeTime = 0
        let leading = false
        let maxing = false
        let trailing = true

        const useRAF = (!wait && wait !== 0 && typeof root.requestAnimationFrame === 'function')

        if (typeof func !== 'function') {
            throw new TypeError('Expected a function')
        }
        wait = +wait || 0
        if (isObject(options)) {
            leading = !!options.leading
            maxing = 'maxWait' in options
            maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait
            trailing = 'trailing' in options ? !!options.trailing : trailing
        }

        function invokeFunc(time) {
            const args = lastArgs
            const thisArg = lastThis

            lastArgs = lastThis = undefined
            lastInvokeTime = time
            result = func.apply(thisArg, args)
            return result
        }

        function startTimer(pendingFunc, wait) {
            if (useRAF) {
            root.cancelAnimationFrame(timerId)
            return root.requestAnimationFrame(pendingFunc)
            }
            return setTimeout(pendingFunc, wait)
        }

        function cancelTimer(id) {
            if (useRAF) {
            return root.cancelAnimationFrame(id)
            }
            clearTimeout(id)
        }

        function leadingEdge(time) {
            lastInvokeTime = time
            timerId = startTimer(timerExpired, wait)
            return leading ? invokeFunc(time) : result
        }

        function remainingWait(time) {
            const timeSinceLastCall = time - lastCallTime
            const timeSinceLastInvoke = time - lastInvokeTime
            const timeWaiting = wait - timeSinceLastCall

            return maxing
            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
            : timeWaiting
        }

        function shouldInvoke(time) {
            const timeSinceLastCall = time - lastCallTime
            const timeSinceLastInvoke = time - lastInvokeTime

            return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
            (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait))
        }

        function timerExpired() {
            const time = Date.now()
            if (shouldInvoke(time)) {
            return trailingEdge(time)
            }
            timerId = startTimer(timerExpired, remainingWait(time))
        }

        function trailingEdge(time) {
            timerId = undefined

            if (trailing && lastArgs) {
            return invokeFunc(time)
            }
            lastArgs = lastThis = undefined
            return result
        }

        function cancel() {
            if (timerId !== undefined) {
            cancelTimer(timerId)
            }
            lastInvokeTime = 0
            lastArgs = lastCallTime = lastThis = timerId = undefined
        }

        function flush() {
            return timerId === undefined ? result : trailingEdge(Date.now())
        }

        function pending() {
            return timerId !== undefined
        }

        function debounced(...args) {
            const time = Date.now()
            const isInvoking = shouldInvoke(time)

            lastArgs = args
            lastThis = this
            lastCallTime = time

            if (isInvoking) {
            if (timerId === undefined) {
                return leadingEdge(lastCallTime)
            }
            if (maxing) {
                timerId = startTimer(timerExpired, wait)
                return invokeFunc(lastCallTime)
            }
            }
            if (timerId === undefined) {
            timerId = startTimer(timerExpired, wait)
            }
            return result
        }
        debounced.cancel = cancel
        debounced.flush = flush
        debounced.pending = pending
        return debounced
    }

    export default debounce    
```

### 实现节流函数(throttle)
```
    const throttle = (fn, delay = 500) => {
        let flag = true;
        return (...args) => {
            if (!flag) return;
            flag = false;
            setTimeout(() => {
                fn.apply(this, args);
                flag = true;
            }, delay);
        };
    };
```
underscore版本:
```
    _.throttle = function(func, wait, options) {
        var timeout, context, args, result;
        var previous = 0;
        if (!options) options = {};

        var later = function() {
        previous = options.leading === false ? 0 : _.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
        };

        var throttled = function() {
        var now = _.now();
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
            clearTimeout(timeout);
            timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
        };

        throttled.cancel = function() {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
        };

        return throttled;
    };
```
lodash版本:
```
    import debounce from './debounce.js'
    import isObject from './isObject.js'
    function throttle(func, wait, options) {
        let leading = true
        let trailing = true

        if (typeof func !== 'function') {
            throw new TypeError('Expected a function')
        }
        if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading
            trailing = 'trailing' in options ? !!options.trailing : trailing
        }
        return debounce(func, wait, {
            leading,
            trailing,
            'maxWait': wait
        })
    }

    export default throttle
```

### 实现lazy-load懒加载
```
    let imgs=document.querySelectorAll('img');
    let clientHeight=window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
    function lazyLoad(){
        let scrollTop=window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
        for(let i=0;i<imgs.length;i++){
            let x=clientHeight + scrollTop-imgs[i].offsetTop;
            if(x>0 && x<clientHeight+imgs[i].height){
                imgs[i].src=imgs[i].getAttribute('data')
            }
        }
    }
```

### 实现拖拽
```
    window.onload=function(){
        let drag=document.getElementById('box');
        drag.onmousedown=function(e){
            let e = e || window.event;
            let diffX=e.clientX-drag.offsetLeft;
            let diffY=e.clientY-drag.offsetTop;
            drag.onmousemove=function(e){
                let left=e.clientX-diffX;
                let top=e.clientY-diffY;
                if(left<0){
                    left=0;
                }else if(left>window.innerWidth-drag.offsetWidth){
                    left=window.innerWidth-drag.offsetWidth;
                }
                if(top<0){
                    top=0;
                }else if(top>window.innerHeight-drag.offsetHeight){
                    top=window.innerHeight-drag.offsetHeight
                }
                drag.style.left=left+'px';
                drag.style.top=top+'px';
            }
            drag.onmouseup=function(e){
                this.onmousemove=null;
                this.onmouseup=null;
            }
        }
    }
```

### 实现基于Promise的ajax函数
```
    function ajax(url,method,fn,type){
        return new Promise((resolve,reject)=>{
                var xhr=new XMLHttpRequest();
                xhr.onreadystatechange=function(){
                    if(xhr.readyState==4){
                        if(xhr.status==200){
                            //var result=xhr.responseText;
                            //fn(result);
                            resolve(JSON.parse(xhr.responseText).count);
                        }	
                    }
                };

                xhr.open(method,url+"?"+type,true);

                if(method=="post"){
                    xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
                }

                if(method=="get"){
                    xhr.send(null);
                }else if(method=="post"){
                    xhr.send(type);
                }

            }
        )	
    }
```

### 实现一个浅克隆
```
    function clone(obj){
        let newObj={};
        for(let key in obj){
            newObj[key]=obj[key];
        }
        return newObj;
    }
```

### 实现一个深克隆(deepclone)
简版：
```
    function clone(obj){
        if(obj===null){
            return null
        };
        if({}.toString.call(obj)==='[object Array]'){
            let newArr=[];
            newArr=obj.slice();
            return newArr;
        };
        let newObj={};
        for(let key in obj){
            if(typeof obj[key]!=='object'){
                newObj[key]=obj[key];
            }else{
                newObj[key]=clone(obj[key]);
            }
        }
    }
```
完整版：
```
    const clone = parent => {
        const isType = (obj, type) => {
            if (typeof obj !== "object") return false;
            const typeString = Object.prototype.toString.call(obj);
            let flag;
            switch (type) {
                case "Array":
                    flag = typeString === "[object Array]";
                    break;
                case "Date":
                    flag = typeString === "[object Date]";
                    break;
                case "RegExp":
                    flag = typeString === "[object RegExp]";
                    break;
                default:
                    flag = false;
            }
            return flag;
        };

        const getRegExp = re => {
            var flags = "";
            if (re.global) flags += "g";
            if (re.ignoreCase) flags += "i";
            if (re.multiline) flags += "m";
            return flags;
        };

        const parents = [];
        const children = [];

        const _clone = parent => {
            if (parent === null) return null;
            if (typeof parent !== "object") return parent;

            let child, proto;

            if (isType(parent, "Array")) {
                child = [];
            } else if (isType(parent, "RegExp")) {
                child = new RegExp(parent.source, getRegExp(parent));
                if (parent.lastIndex) child.lastIndex = parent.lastIndex;
            } else if (isType(parent, "Date")) {
                child = new Date(parent.getTime());
            } else {
                proto = Object.getPrototypeOf(parent);
                child = Object.create(proto);
            }

            const index = parents.indexOf(parent);

            if (index != -1) {
                return children[index];
            }
            parents.push(parent);
            children.push(child);

            for (let i in parent) {
                child[i] = _clone(parent[i]);
            }
            return child;
        };

        return _clone(parent);
    };
```

### 实现一个深比较
```
    function deepCompare(a,b){
        if(a===null || typeof a!=='object' || b===null || typeof b!=='object'){
            return a===b
        }
        const propsA=Object.getOwnPropertyDescriptors(a);
        const propsB=Object.getOwnPropertyDescriptors(b);
        if(Object.keys(propsA).length!==Object.keys(propsB).length){
            return false
        }
        return Object.keys(propsA).every(
            key=>deepCompare(a[key],b[key])
        )
    }
```

### 解析URL Params为对象
```
    function parseParam(url) {
        const paramsStr = /.+\?(.+)$/.exec(url)[1]; 
        const paramsArr = paramsStr.split('&'); 
        let paramsObj = {};
        paramsArr.forEach(param => {
            if (/=/.test(param)) { 
                let [key, val] = param.split('='); 
                val = decodeURIComponent(val); 
                val = /^\d+$/.test(val) ? parseFloat(val) : val; 

                if (paramsObj.hasOwnProperty(key)) { 
                    paramsObj[key] = [].concat(paramsObj[key], val);
                } else { 
                    paramsObj[key] = val;
                }
            } else { 
                paramsObj[param] = true;
            }
        })
        return paramsObj;
    }
```

### 为普通对象添加迭代属性
```
    let obj={};
    Object.defineProperty(obj,Symbol.iterator,{
        enumerable:false,
        writable:false,
        configurable:true,
        value:function(){
            let o=this;
            let idx=0;
            let ks=Object.keys(o);
            return {
                next:function(){
                    return {
                        value:o[ks[idx++]],
                        done:(idx>ks.length)
                    }
                }
            }
        }
    })   
```

### 输出字符串中字符的个数
推荐
```
    let str='helloworld';
    let dict={};
    for(let i=0;i<str.length;i++){
        if(dict[str[i]]===undefined){
            dict[str[i]]=1;
        }else{
            dict[str[i]]+=1;
        }
    }
```

### 查找字符串中出现最多的字符和个数
```
    let str = "abcabcabcbbccccc";
    let num = 0;
    let char = '';

    str = str.split('').sort().join('');

    let re = /(\w)\1+/g;
    str.replace(re,($0,$1) => {
        if(num < $0.length){
            num = $0.length;
            char = $1;        
        }
    });
    console.log(`字符最多的是${char}，出现了${num}次`);
```

### 字符串查找
```
    a='34';b='1234567'; // 返回 2
    a='35';b='1234567'; // 返回 -1
    a='355';b='12354355'; // 返回 5
    isContain(a,b);
    function isContain(a, b) {
        for (let i in b) {
            if (a[0] === b[i]) {
                let tmp = true;
                for (let j in a) {
                    if (a[j] !== b[~~i + ~~j]) {
                    tmp = false;
                    }
                }
                if (tmp) {
                    return i;
                }
            }
        }
        return -1;
    }
```

### 实现字符串翻转

```
    var arr=str.split('');
    var newArr=[];
    for(var i=0;i<arr.length;i++){
        newArr[i]=arr[arr.length-i-1];
    }
    var newStr=newArr.join('')
    console.log(str0);
```

```
    var newStr='';
    for(var i=0;i<str.length;i++){
        newStr+=str.charAt(str.length-i-1);
    }
    console.log(newStr);
```

```
    var newStr=str.split("").reverse().join("");
    console.log(newStr);
```

```
    var arr=str.split('');
    var obj=Array.from(new Set([...arr]));
    var newStr='';
    for(i of obj){
        newStr+=obj[arr.length-i];
    }
    console.log(newStr)
```

```
    var arr=str.split('');
    var newArr=[];
    while(arr.length>0){
        newArr.push(arr.pop())
    };
    var newStr=newArr.join("");
    console.log(newStr)
```

### 实现字符串的散列函数
```
    function h_str(str,M){
        return [...str].reduce((hash,c)=>{
            hash=(31*hash+c.charCodeAt(0))%M
            return hash
        },0)
    }
```

### 实现数组去重
推荐
```
    let dict={},
        result=[],
        j=0;

    for(let i=0;i<arr.length;i++){
        dict[arr[i]]=1;
    }

    for(result[j++] in dict);
```

```
    var newArr=Array.from(new Set(arr));
    console.log(newArr);
```

```
    for(var i=0;i<arr.length;i++){
        for(j=i+1;j<arr.length;j++){
            if(arr[i]==arr[j]){
                arr.splice(j,1);
                j--;
            }
        }
    }
    console.log(arr);
```

```
    var newArr=[];
    for(var i=0;i<arr.length;i++){
        if(newArr.indexOf(arr[i])===-1){
            newArr.push(arr[i])
        }
    }
    console.log(newArr);
```

```
    var arr=arr.sort();
    var newArr=[arr[0]];
    for(var i=1;i<arr.length;i++){
        if(arr[i]!==arr[i-1]){
            newArr.push(arr[i])
        }
    }
    console.log(newArr);
```

```
    var newArr=[];
    var obj={};
    for(var i=0;i<arr.length;i++){
        if(!obj[arr[i]]){
            newArr.push(arr[i]);
            obj[arr[i]]=1
        }else{
            obj[arr[i]]++
        }
    }
    console.log(newArr);
```

```
    var newArr=[];
    for(var i=0;i<arr.length;i++){
        if(!newArr.includes(arr[i])){//检测数组是否有某个值
            newArr.push(arr[i]);
        }
    }
    console.log(newArr);
```

```
    var obj={};
    var newArr=arr.filter((item,index,arr)=>{
        return obj.hasOwnProperty(typeof item+item)?false:(obj[typeof item+item]=true)
    })
    console.log(arrM6);
```

```
    arr.sort(function(a,b){
        return a-b;
    })
    function loop(index){
        if(index>=1){
            if(arr[index]===arr[index-1]){
                arr.splice(index,1);
            }
            loop(index-1)
        }
    }
    loop(arr.length-1);
    console.log(arr);
```

```
    var map=new Map();
    var newArr=[];
    for(var i=0;i<arr.length;i++){
        if(map.has(arr[i])){
            map.set(arr[i],true);
        }else{
            map.set(arr[i],false);
            newArr.push(arr[i]);
        }
    }
    console.log(newArr);
```

```
    arr=arr.reduce((prev,cur)=>prev.includes(cur)?prev:[...prev,cur],[]);
    console.log(arr);
    ```

    ```
    var newArr=[...new Set(arr)];
    console.log(newArr);
```

### 实现旋转数组
```
```

### 实现浮点数的散列函数
```
    function binary_value(val){
        const farr=new Float32Array(1)
        farr[0]=val
        const intBytes=new Int8Array(farr.buffer)
        const view=new DataView(intBytes.buffer)
        return view.getUnit32()
    }
    k=>binary_value(k)%M
```

### 实现千位分隔符
```
    function parseToMoney(num) {
        num = parseFloat(num.toFixed(3));
        let [integer, decimal] = String.prototype.split.call(num, '.');
        integer = integer.replace(/\d(?=(\d{3})+$)/g, '$&,');
        return integer + '.' + (decimal ? decimal : '');
    }
```

```
    function parseToMoney(str){
        let re = /(?=(?!\b)(\d{3})+$)/g; 
        return str.replace(re,','); 
    }
```

### 判断是否是电话号码
```
    function isPhone(tel) {
        var regx = /^1[34578]\d{9}$/;
        return regx.test(tel);
    }
```

### 验证是否是邮箱
```
    function isEmail(email) {
        var regx = /^([a-zA-Z0-9_\-])+@([a-zA-Z0-9_\-])+(\.[a-zA-Z0-9_\-])+$/;
        return regx.test(email);
    }
```

### 验证是否是身份证
```
    function isCardNo(number) {
        var regx = /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/;
        return regx.test(number);
    }
```

### 实现一个函数柯里化
```
```

### 实现一个函数反柯里化
```
```

### 实现数组扁平化
递归
```
    function flatten(arr){
        return [].concat(
            ...arr.map(x=>Array.isArray(x)?flatten(x):x)
        )
    }
```
递归，可以用for去展平拿到想要的第几项，可以忽略后续的非展平项，保证性能
```
    function *flatten(arr){
        for(let i=0;i<arr.length;i++){
            if(Array.isArray(arr[i])){
                yield * flatten(arr[i])
            }else{
                yield arr[i]
            }
        }
    }
```
堆栈实现非递归
```
    function *flatten(arr){
        let stack=arr.slice.reverse();
        while(stack.length){
            const item=stack.pop();
            if(item.constructor===Array){
                stack=stack.concat(item)
            }else{
                yield item
            }
        }
    }
```

### 实现回文数
```
```

### 实现isArray()方法 判断是否为数组
```
    Array.myIsArray=function(o){
        return Object.prototype.toString.call(Object(o)) === '[object Array]'
    }
```

### 实现isContain()方法，判断是否包含该字符串
```
    function isContain(a, b) {
        for (let i in b) {
            if (a[0] === b[i]) {
            let tmp = true;
            for (let j in a) {
                if (a[j] !== b[~~i + ~~j]) {
                tmp = false;
                }
            }
            if (tmp) {
                return i;
            }
            }
        }
        return -1;
    }
```

### 实现isNegZero函数
```
    function isNegZero(n){
        n=Number(n);
        return (n === n) && (1/n === -Infinity)
    }
```

### 实现Object.is()函数
```
    Object.is=function(v1,v2){
        if(v1===0 && v2===0){
            return 1/v1 === 1/v2;
        }
        if(v1!==v1){
            return v2!==v2;
        }
        return v1 === v2;
    }
```

## 原理部分

### 实现Event(event bus)
```
    class EventEmitter {
        constructor() {
            this._events = this._events || new Map(); 
            this._maxListeners = this._maxListeners || 10; 
        }
    }

    EventEmitter.prototype.emit = function(type, ...args) {
        let handler;
        handler = this._events.get(type);
        if (args.length > 0) {
            handler.apply(this, args);
        } else {
            handler.call(this);
        }
        return true;
    };

    EventEmitter.prototype.addListener = function(type, fn) {
        if (!this._events.get(type)) {
            this._events.set(type, fn);
        }
    };

    EventEmitter.prototype.emit = function(type, ...args) {
        let handler;
        handler = this._events.get(type);
        if (Array.isArray(handler)) {
            for (let i = 0; i < handler.length; i++) {
                if (args.length > 0) {
                    handler[i].apply(this, args);
                } else {
                    handler[i].call(this);
                }
            }
        } else {
            if (args.length > 0) {
                handler.apply(this, args);
            } else {
                handler.call(this);
            }
        }
        return true;
    };

    EventEmitter.prototype.addListener = function(type, fn) {
        const handler = this._events.get(type); 
        if (!handler) {
            this._events.set(type, fn);
        } else if (handler && typeof handler === "function") {
            this._events.set(type, [handler, fn]); 
        } else {
            handler.push(fn); 
        }
    };

    EventEmitter.prototype.removeListener = function(type, fn) {
        const handler = this._events.get(type); 

        if (handler && typeof handler === "function") {
            this._events.delete(type, fn);
        } else {
            let position;
            for (let i = 0; i < handler.length; i++) {
                if (handler[i] === fn) {
                    position = i;
                } else {
                    position = -1;
                }
            }

            if (position !== -1) {
                handler.splice(position, 1);
                if (handler.length === 1) {
                    this._events.set(type, handler[0]);
                }
            } else {
                return this;
            }
        }
    };
```
简版
```
    class EventEmitter{
        constructor(){
            this._events={};
        }
        on(type,listener){
            let listeners=this._events[type];
            if(listeners){
                listeners.push(listener)
            }else{
                this._events[type]=[listener];
            }
        }
        emit(type){
            let listeners=this._events[type];
            let args=Array.from(arguments).slice(1);
            listeners.forEach(listener=>listener(...args));
        }
    }
```

### 实现instanceOf
```
    function instance_of(L, R) {
        var O = R.prototype; 
        L = L.__proto__; 
        while (true) {
            if (L === null) return false;
            if (O === L)
            return true;
            L = L.__proto__;
        }
    }
```

### 实现一个new
```
    function objectFactory() {
        const obj = new Object();
        const Constructor = [].shift.call(arguments);

        obj.__proto__ = Constructor.prototype;

        const ret = Constructor.apply(obj, arguments);

        return typeof ret === "object" ? ret : obj;
    }
```

### 实现一个extends
```
    function myExtends(sourceObj,targetObj){
        for(let key in sourceObj){
            if(!(key in targetObj)){
                targetObj[key]=sourceObj[key];
            }
        }
        return targetObj;
    }
```

### 实现一个call
```
    Function.prototype.myCall = function(context) {
        context.fn = this;
        let args = [];
        for (let i = 1, len = arguments.length; i < len; i++) {
            args.push(arguments[i]);
        }
        context.fn(...args);
        let result = context.fn(...args);
        delete context.fn;
        return result;
    };
```

### 实现一个apply
```
    Function.prototype.myapply = function(context, arr) {
        var context = Object(context) || window;
        context.fn = this;

        var result;
        if (!arr) {
            result = context.fn();
        } else {
            var args = [];
            for (var i = 0, len = arr.length; i < len; i++) {
                args.push("arr[" + i + "]");
            }
            result = eval("context.fn(" + args + ")");
        }

        delete context.fn;
        return result;
    };
```

### 实现bind
```
    if (!Function.prototype.bind) {
        Function.prototype.bind = function(oThis) {
            if (typeof this !== 'function') {
                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
            }

            var aArgs   = Array.prototype.slice.call(arguments, 1),
                fToBind = this,
                fNOP    = function() {},
                fBound  = function() {
                return fToBind.apply(this instanceof fBound
                        ? this
                        : oThis,
                        aArgs.concat(Array.prototype.slice.call(arguments)));
                };

            if (this.prototype) {
                fNOP.prototype = this.prototype; 
            }

            fBound.prototype = new fNOP();

            return fBound;
        };
    }
```

### 实现一个软绑定
```
    if(!Function.prototype.softBind){
        Function.prototype.softBind=function(obj){
            let fn=this;
            let curried=[].slice.call(arguments,1);
            let bound=function(){
                return fn.apply(
                    (!this || this===(window || global))?obj:this,
                      curried.concat.apply(curried,arguments)    
                );
            };
            bound.prototype=Object.create(fn.prototype);
            return bound;
        }
    }
```

### 实现super关键字
```
```

### 实现Object.create()
```
    function create(proto) {
        function F() {}
        F.prototype = proto;
        return new F();
    }
```

### 实现类的继承
```
    function Parent(name) {
        this.parent = name
    }
    Parent.prototype.say = function() {
        console.log(`${this.parent}: 你打篮球的样子像kunkun`)
    }
    function Child(name, parent) {
        Parent.call(this, parent)
        this.child = name
    }

    Child.prototype = Object.create(Parent.prototype);
    Child.prototype.say = function() {
        console.log(`${this.parent}好，我是练习时长两年半的${this.child}`);
    }

    Child.prototype.constructor = Child;

    var parent = new Parent('father');
    parent.say();

    var child = new Child('cxk', 'father');
    child.say();
```

### 实现rem原理
```
    function setRem(){
        let doc=document.documentElement;
        let width=doc.getBoundingClientRect().width;
        let rem=width/75;
        doc.style.fontSize=rem+'px'
    }
    addEventListener('resize',setRem)
```

### 实现一个双向数据绑定
```
    let arrayProto=Array.prototype;
    let proto=Object.create(arrayProto);
    ['push','unshift','splice','reverse','sort','shift','pop'].forEach(method=>{
        proto[method]=function(...args){
            let inserted;
            switch(method){
                case 'push':
                case 'unshift':
                    inserted=args
                    break;
                case 'splice':
                    inserted = args.slice(2);
                default:
                    break;
            }
            ArrayObserver(inserted);
            arrayProto[method].call(this,...args)
        }
    })
    function ArrayObserver(obj){
        for(let i=0;i<obj.length;i++){
            let item=obj[i];
            observer(item);
        }
    }
    function observer(obj){
        if(typeof obj !== 'object' || obj == null){
            return obj;
        }
        if(Array.isArray(obj)){
            Object.setPrototypeOf(obj,proto)
            ArrayObserver(obj);
        }else{
            for (let key in obj){
                defineReactive(obj,key,obj[key])
            }
        }
    }
    function defineReactive(obj,key,value){
        observer(value); // 递归创建
        get(){
            return value;
        },
        set(newValue){
            if(value!==newValue){
                observer(newValue);
                value=newValue;
            }
        }
    }
```

### 实现Worker
```
```

### 实现jwt
```
```

### 实现Vuex
```
```

### 实现Redux
```
    // bindActionCreator
    export default function bindActionCreator(actions,dispatch){
        let newActions={};
        for(let key in actions){
            newActions[key]=()=>dispatch(actions[key].apply(null,arguments));
        }
        return newActions;
    }
    // combineReducers
    export default combineReducers=reducers=>(state={},action)=>Object.keys(reducers).reduce((currentState,key)=>{
        currentState[key]=reducers[key](state[key],action);
        return currentState;
    },{});
    // createStore
    export default function createStore(reducer,enhancer){
        if(typeof enhancer !== 'undefined'){
            return enhancer(createStore)(reducer);
        }
        let state=null;
        const listeners=[];
        const subscribe=(listener)=>{
            listeners.push(listener);
        }
        const getState=()=>state;
        const dispatch=(action)=>{
            state=reducer(state,action);
            listeners.forEach((listener)=>listener())
        };
        dispatch({});
        return {getState,dispatch,subscribe}
    }
    // applyMiddleware
    export default function applyMiddleware(...middlewares){
        return (createStore)=>(reducer)=>{
            const store=createStore(reducer);
            let dispatch=store.dispatch;
            let chain=[];

            const middlewareAPI={
                getState:store.getState,
                dispatch:(action)=>dispatch(action)
            }
            chain=middlewares.map(middleware=>middleware(middlewareAPI));
            dispatch=compose(...chain)(store.dispatch);

            return {
                ...store,
                dispatch
            }
        }
    }
    // compose
    export default function compose(...funcs){
        return funcs.reduce((a,b)=>(...args)=>a(b(...args)));
    }
```

### 实现虚拟dom渲染原理
```
```

### 实现一个简单路由
```
    class Route{
        constructor(){
            this.routes={};
            this.currentHash='';
            this.freshRoute=this.freshRoute.bind(this);
            window.addEventListener('load',this.freshRoute,false);
            window.addEventListener('hashchange',this.freshRoute,false);
        }
        storeRoute(path,cb){
            this.routes[path]=cb || function(){}
        }
        freshRoute(){
            this.currentHash=location.hash.slice(1) || '/';
            this.routes[this.currentHash]()
        }
    }
```

### 实现Promise
```
    const PENDING='pending';
    const FULFILLED='fulfilled';
    const REJECTED='rejected';

    function MyPromise(fn){
        const self=this;
        self.value=null;
        self.error=null;
        self.status=PENDING;
        self.onFulfilledCallbacks=[];
        self.onRejectedCallbacks=[];

        function resolve(value){
            if(value instanceof MyPromise){
                return value.then(resolve,reject);
            }
            if(self.status===PENDING){
                setTimeout(()=>{
                    self.status=FULFILLED;
                    self.value=value;
                    self.onFulfilledCallbacks.forEach((callback)=>callback(self.value));
                },0)
            }
        }

        function reject(error){
            if(self.status===PENDING){
                setTimeout(function(){
                    self.status=REJECTED;
                    self.error=error;
                    self.onRejectedCallbacks.forEach((callback)=>callback(self.error))
                },0)
            }
        }
        try{
            fn(resolve,reject);
        }catch(e){
            reject(e);
        }
    }

    function resolvePromise(bridgepromise,x,resolve,reject){
        if(bridgepromise===x){
            return reject(new TypeError('Circular reference'));
        }

        let called=false;
        if(x instanceof MyPromise){
            if(x.status===PENDING){
                x.then(y=>{
                    resolvePromise(bridgepromise,y,resolve,reject)
                },error=>{
                    reject(error);
                })
            }else{
                x.then(resolve,reject)
            }
        }else if(x!=null && ((typeof x === 'object') || (typeof x === 'function'))){
            try{
                let then=x.then;
                if(typeof then === 'function'){
                    then.call(x,y=>{
                        if(called) return;
                        called=true;
                        resolvePromise(bridgepromise,y,resolve,reject)
                    },error=>{
                        if(called) return;
                        called=true;
                        reject(error);
                    })
                }else{
                    resolve(x);
                }
            }catch(e){
                if(called) return;
                called=true;
                reject(e);
            }
        }else{
            resolve(x);
        }
    }

    MyPromise.prototype.then=function(onFulfilled,onRejected){
        const self=this;
        let bridgePromise;
        onFulfilled=typeof onFulfilled==='function'?onFulfilled:value=>value;
        onRejected=typeof onRejected==='function'?onRejected:error=>{throw error};
        if(self.status===FULFILLED){
            return bridgePromise=new MyPromise((resolve,reject)=>{
                setTimeout(()=>{
                    try{
                        let x=onFulfilled(self.value);
                        resolvePromise(bridgePromise,x,resolve,reject);
                    }catch(e){
                        reject(e);
                    }
                },0)
            })
        }
        if(self.status===REJECTED){
            return bridgePromise=new MyPromise((resolve,reject)=>{
                setTimeout(()=>{
                    try{
                        let x=onRejected(self.error);
                        resolvePromise(bridgePromise,x,resolve,reject);
                    }catch(e){
                        reject(e);
                    }
                },0)
            })
        }
        if(self.status===PENDING){
            return bridgePromise=new MyPromise((resolve,reject)=>{
                self.onFulfilledCallbacks.push((value)=>{
                    try{
                        let x=onFulfilled(value);
                        resolvePromise(bridgePromise,x,resolve,reject)
                    }catch(e){
                        reject(e);
                    }
                });
                self.onRejectedCallbacks.push((error)=>{
                    try{
                        let x=onRejected(error);
                        resolvePromise(bridgePromise,x,resolve,reject);
                    }catch(e){
                        reject(e);
                    }
                });
            });
        }
    }
    MyPromise.prototype.catch=function(onRejected){
        return this.then(null,onRejected);
    }
    MyPromise.deferred=function(){
        let defer={};
        defer.promise=new MyPromise((resolve,reject)=>{
            defer.resolve=resolve;
            defer.reject=reject;
        });
        return defer;
    }
    try{
        module.exports=MyPromise;
    }catch(e){}
```

### 实现promise的生成器run方法
```
    function run(gen){
        let args=[].slice.call(arguments,1),
            it;
        it=gen.apply(this,args);

        return Promise.resolve().then(function handleNext(value){
            let next =it.next(value);

            return (function handleResult(next){
                if(next.done){
                    return next.value;
                }else{
                    return Promise.resolve(next.value).then(
                        handleNext,
                        function handleErr(err){
                            return Promise.resolve(
                                if.throw(err)
                            ).then(handleResult);
                        }
                    );
                }
            })(next);
        })
    }
```

### 实现promisify
```
    function promisify(fn){
        return function(...args){
            return new Promise(function(resolve,reject){
                fn(...args,function(err,data){
                    if(err){
                        reject(err)
                    }else{
                        resolve(data);
                    }
                };
            });
        }
    }
```

### 实现thunkify
```
    function thunkify(fn){
        let args=[].slice.call(arguments,1);
        return function(cb){
            args.push(cb);
            return fn.apply(null,args);
        }
    }
```

### 使用setTimeout实现setInterval
```
    setTimeout(function(){
        setTimeout(arguments.callee,500)
    },500)
```

### 实现JSON.parse
```
    var json = '{"name":"cxk", "age":25}';
    var obj = eval("(" + json + ")");
```

### 实现JSON.stringify
```
```

### 实现indexOf方法
```
    function indexOf(arr,elem,fromi){
        fromi=fromi||0;
        for(var i=fromi;i<arr.length;i++){
            if(elem===arr[i]){
                return i;
            }
        }
    return -1;
    }
```

### 实现reduce方法
```
    Array.prototype.myreduce=function reduce(callbackfn){
        const o=this,
              len=o.length;
        let k=0,
            accumulator=undefined,
            kPresent=false,
            initialValue=arguments.length>1?arguments[1]:undefined;
        
        if(typeof callbackfn !== 'function'){
            throw new TypeError(callbackfn+'is not a function');
        }

        if(len === 0 && arguments.length<2){
            throw new TypeError('Reduce of empty array with no initial value');
        }

        if(arguments.length>1){
            accumulator=initialValue;
        }else{
            accumulator=o[k];
            ++k;
        }

        while(k<len){
            kPresent=o.hasOwnProperty(k);

            if(kPresent){
                const kValue=o[k];
                accumulator=callbackfn.apply(undefined,[accumulator,kValue,k,o]);
            }
            ++k;
        }

        return accumulator;
    }
```

### 实现trim方法
```
    function trim(str){
        if(str && typeof str==='string'){
            return str.replace(/^\s+l\s+$/g/,'')
        }
    }
```

### 实现join方法
```
    function join(arr,connector){
        let str='';
        for(let i=0;i<arr.length;i++){
            if(i>0){
                str+=connector;
            }
            if(arr[i] !== undefined){
                str+=arr[i];
            }
        }
        return str;
    }
```

### 实现一个模板引擎 
```
    function render(template, data) {
        const reg = /\{\{(\w+)\}\}/; 
        if (reg.test(template)) { 
            const name = reg.exec(template)[1]; 
            template = template.replace(reg, data[name]); 
            return render(template, data); 
        }
        return template; 
    }
```

### 实现一个转驼峰方法camelCase
```
    function camelCase(str){
        return str.replace(/-\w/g,function(newStr){
            return newStr.slice(1).toUpperCase();
        })
    }
```

### 实现Virtual Dom && Diff
```
```

### 实现一个简版jQuery
```
    (function(window,undefined){
        let njQuery=function(){
            return new njQuery.prototype.init();
        }
        njQuery.prototype={
            constructor:njQuery
        }
        njQuery.prototype.init.prototype=njQuery.prototype;
        window.njQuery=window.$=njQuery;
    })(window)
```

## 算法部分

### 实现冒泡排序
```
    function swap(A,i,j){
        const t=A[i];
        A[i]=A[j];
        A[j]=t;
    }
    function buble_sort(A){
        // |---未排序---|---已排序的最大值---|
        // 初始 |------未排序------|i|
        for(let i=A.length;i>0;i--){
            for(let j=1;j<i;j++){
                if(A[j]<A[j-1]){
                    swap(A,j,j-1)
                }
            }
            // 循环不变式成立
        }
        return A
    }
```

### 实现快速排序
```
    // i指向最后一个小于支点的数字，j指向未确认的下一个数字 初始值 i=-1,j=0
    function swap(A,i,j){
        [A[i],A[j]]=[A[j],A[i]];
    }

    function divide(A,p,r){
        const x=A[r-1];
        let i=p-1;
        for(let j=p;j<r-1;j++){
            if(A[j]<x){
                i++;
                swap(A,i,j);
            }
        }
        swap(A,i+1,r-1);
        return i+1;
    }

    function quick_sort(A,p=0,r){
        r = typeof r !== 'undefined' ? r : A.length;
        if(p<r-1){
            const q=divide(A,p,r);
            quick_sort(A,p,q);
            quick_sort(A,q+1,r)
        }
    }
```

### 实现插入排序
```
    function insert_sort(A){
        for(
            let j=1;                    
            j<A.length;                 
            j++){                       
            const key=A[j];             
            let i=j-1;                  
            while(i>=0 && A[i]>key){    
                A[i+1]=A[i];            
                i--;                    
            }
            A[i+1]=key                  
        }
    }
```

### 实现归并排序
```
    const SENTINEL=Number.MAX_SAFE_INTEGER;

    function divide(p,r){
        return Math.floor((p+r)/2)
    }

    function conquer(A,p,q,r){
        const A1=A.slice(p,q);
        const A2=A.slice(q,r);

        A1.push(SENTINEL);
        A2.push(SENTINEL);

        for(let k=p,i=0,j=0;k<r;k++){
            A[k]=A1[i]<A2[i]?A1[i++]:A2[j++]
        }
    }

    function merge_sort(A,p=0,r){
        r=r || A.length;
        if(r-p===1){return}
        if(r-p===2){
            if(A[p]>A[r-1]){
                [A[p],A[r-1]]=[A[r-1],A[p]]
            }
            return
        }

        const q=divide(p,r);
        console.log('divide:'+q);
        merge_sort(A,p,q)
        merge_sort(A,q,r)
        conquer(A,p,q,r)
    }
```

### 实现桶排序
```
function bucket_sort(A,max){
    const a=max;
    const B=[...Array(a+1)].map(x=>[])

    const indexFunc=(value)=>{
        const key=Math.floor(value/a);
        if(key>a){
            return a
        }     
        return key
    }

    A.forEach(value=>{
        const idx=Math.floor(indexFunc(value))
        if(!B[idx]){
            throw new Error('桶脚标没有命中 index='+idx)
        }
        B[idx].push(value)
    })

    return [].concat(...B.map(bucket=>{
        return bucket.sort((x,y)=>x-y)
    }))
}
```

### 实现二分查找
```
    function bsearch(A,x){
        let l=0,
            r=A.length-1,
            guess;
        while(l<=r){
            guess=Math.floor((l+r)/2);
            if(A[guess]===x){
                return guess;
            }else if(A[guess]>x){
                r=guess-1;
            }else{
                l=guess+1
            }
        }
        return -1;
    }
```

### 实现红黑树
```

```

### 实现分段树
```
```

### 实现Merkle Tree
```
```

### 实现字典树
```
```

### 使用堆栈简单的符号匹配
```
    function match(n,c){
        return (
            c=='[' && n==']'
        ) ||
        (
            c=='(' && n==')'
        )
    }

    function is_balance(str){
        const [first,...others]=str;
        const stack=[first];
        while(others.length>0){
            const c=stack[stack.length-1];
            const n=others.shift();
            if(!match(n,c)){
                stack.push(n)
            }else{
                stack.pop()
            }
        }
        return stack.length === 0;
    }
```

### 实现广度优先遍历和深度优先遍历
堆栈实现深度优先遍历
```
    function depth_first_search(node){
        let stack=[node];
        while(stack.length>0){
            const item=stack.pop();
            for(let i=item.length-1;i>0;i--){
                stack.push(item.children[i])
            }
        }
    }
```
队列实现广度优先搜索
```
    function *breath_first_search(node){
        let queue=[node];
        while(queue.length>0){
            const item=queue.pop();
            yield item.tagName;
            for(let i=item.length-1;i>0;i--){
                queue.unshift(item.children[i])
            }
        }
    }
```

## 综合部分

### 实现convert方法，将原始list转换成树形结构
```
```

### (LeetCode) 为LRU Cache设计一个数据结构，它支持两个操作：1) get(key):如果key在cache中，则返回对应的value值，否则返回-1；2) set(key,value):如果key不在cache中，则将该(key,value)插入cache中(注意，如果cache已满，则必须把最近最久未使用的元素从cache中删除)；如果key在cache 中，则重置value的值
```
    
```

### 附带有权重的任务，权重由高到低逐项执行。期间，有可能会有任务的权重得到提升，有任务插入。这就构成了一个优先级队列。优先级队列可以用对实现，支持下列操作：1) 插入；2) 提取优先级最大的任务；3) 提升某一个任务的权重
```
```

### 实现一个无缝轮播图
- html部分
```
    <div class="container" id="container">
        <div id="btn-prev" class="btn-ctrl">&lt;</div>
        <div id="btn-next" class="btn-ctrl">&gt;</div>
        <ul id="inner-list">
            <li><img src="images/head1.jpeg" alt=""/></li>
            <li><img src="images/head2.jpeg" alt=""/></li>
            <li><img src="images/head3.jpeg" alt=""/></li>
        </ul>
        <ul id="dot-list">
           
        </ul>
    </div>
```
- js部分
```
window.onload = function(){
    var eleInners = document.getElementById('inner-list'),
        eleDots = document.getElementById('dot-list'),
        liImgs = eleInners.getElementsByTagName('li'),
        liDots = eleDots.children,
        elePrev = document.getElementById('btn-prev'),
        eleNext = document.getElementById('btn-next'),
        LI_WIDTH = liImgs[0].offsetWidth,
        TIME_DURATION = 3000,
        interval = null,
        index = 0,
        circle = 0;
    eleInners.appendChild(liImgs[0].cloneNode(true));

    for(var i= 0,len = liImgs.length -1;i<len;i++){
        var li = document.createElement('li');
        li.innerHTML = i+1;
        eleDots.appendChild(li)
    };

    liDots[0].className = 'cur';

    function animate(obj,targetPlace){
        clearInterval(obj.timer);
        obj.timer = setInterval(function(){
            var speed = obj.offsetLeft > targetPlace ? -15:15;
            var result = targetPlace - obj.offsetLeft;
            
            if(Math.abs(result) > Math.abs(speed)){
                obj.style.left = obj.offsetLeft + speed +'px'
            }else{
                obj.style.left = targetPlace+'px';
                clearInterval(obj.timer);
            }
        },10)
    }

    interval = setInterval(autoplay,3000)

    function autoplay(){
        index++;
        
        if(index > liImgs.length -1){
            eleInners.style.left = 0;
            index = 1;
        }

        animate(eleInners, -index * LI_WIDTH);
        circle++;

        if(circle >= liImgs.length -1){
            circle = 0;
        }
        
        for(var i= 0,len = liDots.length;i<len;i++){
            liDots[i].className ='';
        }

        liDots[circle].className = 'cur';
    }

    function moveright(){
        index--;

        if(index <0){
            eleInners.style.left = -(liImgs.length -2)* LI_WIDTH + 'px';
            index = liImgs.length -2;
        }
        
        animate(eleInners, -index * LI_WIDTH);
        
        circle --;

        if(circle < 0){
            circle = liImgs.length - 2;//circle回到最后一个点
        }

        for(var i= 0,len = liDots.length;i<len;i++){
            liDots[i].className ='';
        }

        liDots[circle].className = 'cur'
    }

    eleInners.addEventListener('mouseenter',function(event){
        clearInterval(interval)
    });

    eleInners.addEventListener('mouseleave',function(event){
        interval = setInterval(autoplay,3000)
    });

    eleDots.addEventListener('click',function(event){
        clearInterval(interval);
        var target = event.target;
        var currentTarget = event.currentTarget;
        index = target.innerHTML - 0 - 1;
        circle = index ;

        for(var i= 0,len = liDots.length;i<len;i++){
            liDots[i].className ='';
        }

        liDots[circle].className = 'cur';
        animate(eleInners, - index * LI_WIDTH);
    })

    elePrev.addEventListener('click',function(event){
        clearInterval(interval)
        moveright();
        interval = setInterval(autoplay,3000)
    })

    eleNext.addEventListener('click',function(event){
        clearInterval(interval);
        autoplay();
        interval = setInterval(autoplay,3000);
    })
}
```

### 写一个幻灯片（css加分）
- html部分：
```
    <div class="myDiv"></div>
```
- css部分：
```
    .myDiv{
        width: 600px;
        height: 400px;
        margin: 20px auto;
        background-size: over;
        background-position: center;
        animation-name:loop;
        animation-duration: 20s;
        animation-iteration-count: infinite;
    }
    @keyframes loop{
        0% {background: url('图片1.jpg') no-repeat;}
        25% {background: url('图片2.jpg') no-repeat;}
        50% {background: url('图片3.jpg') no-repeat;}
        75% {background: url('图片4.jpg') no-repeat;}
        100% {background: url('图片5.jpg') no-repeat;}
    }
```

### 绘制一个等腰三角形
- html部分：
```
    <canvas id="canvas" width="300px" height="300px"></canvas>
```
- script部分：
```
    let ctx=document.getElementById('canvas').getContext('2d');
    ctx.beginPath();
    ctx.moveTo(0,150);
    ctx.lineTo(150,0);
    ctx.lineTo(300,150);
    ctx.closePath();
    ctx.strokeStyle='#666';
    ctx.lineWidth=3;
    ctx.stroke();
```

### 用JavaScript实现斐波那契数列函数，返回第n个斐波那切数。fib(1)=1,fib(2)=1,fib(3)=2等
递归
```
    function fib(n) {
        return fib(n) = n > 2 ?
            fib(n - 1) + fib(n - 2) :
            1
    }
```
非递归 动态规划
```
    function fib(n){
        let a=1,
            b=1;
        for(let i=2;i<n;i++){
            const t=b;
            b=a+b;
            a=t
        }
        return b
    }
```
非递归 生成器
```
    function *fib(){
        let a=1,b=1;
        yield a;
        yield b;
        while(true){
            const t=b;
            b=a+b;
            a=t;
            yield b
        }
    }
```
递归 reduce流
```
    function fib(n){
        return Array(n).fill().reduce(([a,b],_)=>{
            return [b,a+b]
        },[0,1])[0]
    }
```
非递归 堆栈
```
    function fib(n){
        let stack=[n]
        while(stack.length){
            const item=stack.pop();
            if(item===1 || item===2){
                stack.push(1)
            }else{
                stack.push(item-1);
                stack.push(item-2);
            }
        }
    }
```

### 判断一个数是否是素数
```
    function is_prime(n){
        if(n<=1){return false}
        const N=Math.floor(Math.sqrt(n));
        let is_prime=true
        for(let i=2;i<=N;i++){
            if(n%i===0){
                is_prime=false;
                break;
            }
        }
        return is_prime;
    }
```

### 获取n以内所有的素数
```
    function *sieve_primes(n){
        let numbers=Array.from({length:n-2},(_,i)=>i+2);
        let p=null;
        while((p=numbers.shift())){
            yield p;
            numbers=numbers.filter(t=>t%p!==0)
        }
    }
```

### 删除数组arr第一个元素。不要直接修改数组arr，结果返回新的数组。

```
    function insert(arr, item, index) {
        return arr.slice(0,index).concat(item,arr.slice(index));
    }
```

```
    function insert(arr, item, index) {
        var newArr=arr.concat();
        newArr.splice(index,0,item);
        return newArr;
    }
```

```
    function insert(arr, item, index) {
        var newArr=arr.slice(0);
        newArr.splice(index,0,item);
        return newArr;
    }
```

```
    function insert(arr, item, index) {
        var newArr=[];
        [].push.apply(newArr, arr);
        newArr.splice(index,0,item);
        return newArr;
    }
```

### 实现一个打点计时器，要求：(1)从start到end（包含start和end），每隔100毫秒console.log一个数字，每次数字增幅为1；(2)返回的对象中需要包含一个cancel方法，用于停止定时操作；(3)第一个数需要立即输出
```
    function count(start, end) {
        console.log(start)
        var timer = setInterval(
            function(){
                if(start<end) console.log(start+=1);
            },100)
        return {cancel:function(){clearInterval(timer)}}
    }
```

### sort方法将数组内的对象进行排序
```
    function compare(propertyName, index) {
        return function(a, b) {
            let value1 = a[propertyName];
            let value2 = b[propertyName];
            if (vm.reverse[index]) {
                return value2 - value1;
            } else {
                return value1 - value2;
            }
        };
    }
```

### 查找字符串中出现最多的字符和个数
```
    let num=0;
    let char='';

    let str = str.split('').sort().join('');
    str.replace(/(\w)\1+/g,($0,$1) => {
        if(num < $0.length){
            num = $0.length;
            char = $1;        
        }
    });
    console.log(`字符最多的是${char}，出现了${num}次`);
```

### 实现一个方法，随机打乱一个数组
```
    function shuffle_simple(arr){
        return arr.sort(()=>Math.random()- .5)
    }
```
或
```
    function fisher_yates_shuffle(arr){
        for(let i=0;i<arr.length-1;i++){
            const j=i+Math.floor(Math.random()*(arr.length-1));
            [arr[i],[arr[j]]]=[arr[j],arr[i]]
        }
        return arr
    }
```
或
```
    function shuffle(arr){
        const m=[];
        const N=arr.length*arr.length*arr.length;
        for(let i=0;i<arr.length-1;i++){
            m[i]=Math.floor(Math.random(1,N))
        }
        return arr.sort((i,j)=>m[i]-m[j])
    }
```

### 实现一个类似百度搜索框的模糊查询
```
```

### 实现页面整屏切换
```
```

### 实现一个瀑布流效果
```
```

### 实现一个树组件
```
```

### 实现一个购物车动效
```
```

### 实现函数找到DOM的绝对位置
```
    function get_layout(ele){
        const layout={
            width:ele.offsetWidth,
            height:ele.offsetHeight,
            left:ele.offsetLeft,
            top:ele.offsetTop
        }
        if(ele.offsetParent){
            const parentLayout=get_layout(ele.offsetParent);
            layout.left+=parentLayout.left;
            layout.top+=parentLayout.top;
        }
        return layout;
    }
```

### 子数组整除：写一个函数，给定一个数组，判断数组中某一项，或者任意多项的和，是否被另一个整数整除。比如：solve([3,5,8],13)=true;solve([3,9],15)=false;solve([7,8,2],7)=true;solve([1,2,3],6)=true
```
    function solve(arr,N){
        const s=new Set([arr.shift()%N]);
        while(arr.length>0){
            const ak=arr.shift();
            const items=[...s];
            items.forEach(x=>{
                s.add((x+ak)%N);
            })
            s.add(ak)
        }
        return s.has(0);
    }
```

### 实现一段脚本，使得点击对应链接alert出响应的编号
```
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <body>
        <a href="#">第一个链接</a></br>
        <a href="#">第二个链接</a></br>
        <a href="#">第三个链接</a></br>
        <a href="#">第四个链接</a></br>
    </body>
```
```
    <script>
        let aGroup=document.getElementsByTagName('a');
        let i=0;
        for(let a of aGroup){
            a.onclick=(function(i){
                return function(){
                    alert(i);
                }
            })(++i)
        }
    </script>
```

### 请编写一个JavaScript函数parseQueryString，它的用途是把URL参数解析为一个对象，如：var url="http://witmax.cn/index.php?key0=0&key1=1&key2=2"
```
    function parseQueryString(url){
        let search=url.split('?')[1];
        let strs=search.split('&');
        let params={};
        for(let str of strs){
            let arr=str.split('=');
            params[arr[0]]=isNaN(arr[1])?arr[1]:Number(arr[1]);
        }
        return params;
    }
```