# 编程题

## 方法库部分

### 实现防抖函数(debounce)
```
    const debounce = (fn, delay) => {
        let timer = null;
        return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => {
                fn.apply(this, args);
            }, delay);
        };
    };
```

### 实现节流函数(throttle)
```
    const throttle = (fn, delay = 500) => {
        let flag = true;
        return (...args) => {
            if (!flag) return;
            flag = false;
            setTimeout(() => {
                fn.apply(this, args);
                flag = true;
            }, delay);
        };
    };
```

### 实现lazy-load懒加载
```
    let imgs=document.querySelectorAll('img');
    let clientHeight=window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
    function lazyLoad(){
        let scrollTop=window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
        for(let i=0;i<imgs.length;i++){
            let x=clientHeight + scrollTop-imgs[i].offsetTop;
            if(x>0 && x<clientHeight+imgs[i].height){
                imgs[i].src=imgs[i].getAttribute('data')
            }
        }
    }
```

### 实现拖拽
```
    window.onload=function(){
        let drag=document.getElementById('box');
        drag.onmousedown=function(e){
            let e = e || window.event;
            let diffX=e.clientX-drag.offsetLeft;
            let diffY=e.clientY-drag.offsetTop;
            drag.onmousemove=function(e){
                let left=e.clientX-diffX;
                let top=e.clientY-diffY;
                if(left<0){
                    left=0;
                }else if(left>window.innerWidth-drag.offsetWidth){
                    left=window.innerWidth-drag.offsetWidth;
                }
                if(top<0){
                    top=0;
                }else if(top>window.innerHeight-drag.offsetHeight){
                    top=window.innerHeight-drag.offsetHeight
                }
                drag.style.left=left+'px';
                drag.style.top=top+'px';
            }
            drag.onmouseup=function(e){
                this.onmousemove=null;
                this.onmouseup=null;
            }
        }
    }
```

### 实现基于Promise的ajax函数
```
    function ajax(url,method,fn,type){
        return new Promise((resolve,reject)=>{
                var xhr=new XMLHttpRequest();
                xhr.onreadystatechange=function(){
                    if(xhr.readyState==4){
                        if(xhr.status==200){
                            //var result=xhr.responseText;
                            //fn(result);
                            resolve(JSON.parse(xhr.responseText).count);
                        }	
                    }
                };

                xhr.open(method,url+"?"+type,true);

                if(method=="post"){
                    xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
                }

                if(method=="get"){
                    xhr.send(null);
                }else if(method=="post"){
                    xhr.send(type);
                }

            }
        )	
    }
```

### 实现一个深克隆(deepclone)
```
    const clone = parent => {
        const isType = (obj, type) => {
            if (typeof obj !== "object") return false;
            const typeString = Object.prototype.toString.call(obj);
            let flag;
            switch (type) {
                case "Array":
                    flag = typeString === "[object Array]";
                    break;
                case "Date":
                    flag = typeString === "[object Date]";
                    break;
                case "RegExp":
                    flag = typeString === "[object RegExp]";
                    break;
                default:
                    flag = false;
            }
            return flag;
        };

        const getRegExp = re => {
            var flags = "";
            if (re.global) flags += "g";
            if (re.ignoreCase) flags += "i";
            if (re.multiline) flags += "m";
            return flags;
        };

        const parents = [];
        const children = [];

        const _clone = parent => {
            if (parent === null) return null;
            if (typeof parent !== "object") return parent;

            let child, proto;

            if (isType(parent, "Array")) {
                child = [];
            } else if (isType(parent, "RegExp")) {
                child = new RegExp(parent.source, getRegExp(parent));
                if (parent.lastIndex) child.lastIndex = parent.lastIndex;
            } else if (isType(parent, "Date")) {
                child = new Date(parent.getTime());
            } else {
                proto = Object.getPrototypeOf(parent);
                child = Object.create(proto);
            }

            const index = parents.indexOf(parent);

            if (index != -1) {
                return children[index];
            }
            parents.push(parent);
            children.push(child);

            for (let i in parent) {
                child[i] = _clone(parent[i]);
            }
            return child;
        };

        return _clone(parent);
    };
```

### 解析URL Params为对象
```
    function parseParam(url) {
        const paramsStr = /.+\?(.+)$/.exec(url)[1]; 
        const paramsArr = paramsStr.split('&'); 
        let paramsObj = {};
        paramsArr.forEach(param => {
            if (/=/.test(param)) { 
                let [key, val] = param.split('='); 
                val = decodeURIComponent(val); 
                val = /^\d+$/.test(val) ? parseFloat(val) : val; 

                if (paramsObj.hasOwnProperty(key)) { 
                    paramsObj[key] = [].concat(paramsObj[key], val);
                } else { 
                    paramsObj[key] = val;
                }
            } else { 
                paramsObj[param] = true;
            }
        })
        return paramsObj;
    }
```

### 查找字符串中出现最多的字符和个数
```
    let str = "abcabcabcbbccccc";
    let num = 0;
    let char = '';

    str = str.split('').sort().join('');

    let re = /(\w)\1+/g;
    str.replace(re,($0,$1) => {
        if(num < $0.length){
            num = $0.length;
            char = $1;        
        }
    });
    console.log(`字符最多的是${char}，出现了${num}次`);
```

### 字符串查找
```
    a='34';b='1234567'; // 返回 2
    a='35';b='1234567'; // 返回 -1
    a='355';b='12354355'; // 返回 5
    isContain(a,b);
    function isContain(a, b) {
        for (let i in b) {
            if (a[0] === b[i]) {
            let tmp = true;
            for (let j in a) {
                if (a[j] !== b[~~i + ~~j]) {
                tmp = false;
                }
            }
            if (tmp) {
                return i;
            }
            }
        }
        return -1;
    }
```

### 实现字符串翻转

```
var arr=str.split('');
var newArr=[];
for(var i=0;i<arr.length;i++){
    newArr[i]=arr[arr.length-i-1];
}
var newStr=newArr.join('')
console.log(str0);
```

```
var newStr='';
for(var i=0;i<str.length;i++){
    newStr+=str.charAt(str.length-i-1);
}
console.log(newStr);
```

```
var newStr=str.split("").reverse().join("");
console.log(newStr);
```

```
var arr=str.split('');
var obj=Array.from(new Set([...arr]));
var newStr='';
for(i of obj){
    newStr+=obj[arr.length-i];
}
console.log(newStr)
```

```
var arr=str.split('');
var newArr=[];
while(arr.length>0){
    newArr.push(arr.pop())
};
var newStr=newArr.join("");
console.log(newStr)
```

### 实现数组去重

```
var newArr=Array.from(new Set(arr));
console.log(newArr);
```

```
for(var i=0;i<arr.length;i++){
    for(j=i+1;j<arr.length;j++){
        if(arr[i]==arr[j]){
            arr.splice(j,1);
            j--;
        }
    }
}
console.log(arr);
```

```
var newArr=[];
for(var i=0;i<arr.length;i++){
    if(newArr.indexOf(arr[i])===-1){
        newArr.push(arr[i])
    }
}
console.log(newArr);
```

```
var arr=arr.sort();
var newArr=[arr[0]];
for(var i=1;i<arr.length;i++){
    if(arr[i]!==arr[i-1]){
        newArr.push(arr[i])
    }
}
console.log(newArr);
```

```
var newArr=[];
var obj={};
for(var i=0;i<arr.length;i++){
    if(!obj[arr[i]]){
        newArr.push(arr[i]);
        obj[arr[i]]=1
    }else{
        obj[arr[i]]++
    }
}
console.log(newArr);
```

```
var newArr=[];
for(var i=0;i<arr.length;i++){
    if(!newArr.includes(arr[i])){//检测数组是否有某个值
        newArr.push(arr[i]);
    }
}
console.log(newArr);
```

```
var obj={};
var newArr=arr.filter((item,index,arr)=>{
    return obj.hasOwnProperty(typeof item+item)?false:(obj[typeof item+item]=true)
})
console.log(arrM6);
```

```
arr.sort(function(a,b){
    return a-b;
})
function loop(index){
    if(index>=1){
        if(arr[index]===arr[index-1]){
            arr.splice(index,1);
        }
        loop(index-1)
    }
}
loop(arr.length-1);
console.log(arr);
```

```
var map=new Map();
var newArr=[];
for(var i=0;i<arr.length;i++){
    if(map.has(arr[i])){
        map.set(arr[i],true);
    }else{
        map.set(arr[i],false);
        newArr.push(arr[i]);
    }
}
console.log(newArr);
```

```
arr=arr.reduce((prev,cur)=>prev.includes(cur)?prev:[...prev,cur],[]);
console.log(arr);
```

```
var newArr=[...new Set(arr)];
console.log(newArr);
```

### 实现旋转数组
```
```

### 实现千位分隔符
```
```

### 判断是否是电话号码
```
```

### 验证是否是邮箱
```
```

### 验证是否是身份证
```
```

### 实现一个函数柯里化
```
```

### 实现一个函数反柯里化
```
```

### 实现数组扁平化
```
```

### 实现一个数组去重
```
```

### 实现回文数
```
```

### 实现isArray()方法 判断是否为数组
```
```


## 原理部分

### 实现Event(event bus)
```
    class EventEmitter {
        constructor() {
            this._events = this._events || new Map(); 
            this._maxListeners = this._maxListeners || 10; 
        }
    }

    EventEmitter.prototype.emit = function(type, ...args) {
        let handler;
        handler = this._events.get(type);
        if (args.length > 0) {
            handler.apply(this, args);
        } else {
            handler.call(this);
        }
        return true;
    };

    EventEmitter.prototype.addListener = function(type, fn) {
        if (!this._events.get(type)) {
            this._events.set(type, fn);
        }
    };

    EventEmitter.prototype.emit = function(type, ...args) {
        let handler;
        handler = this._events.get(type);
        if (Array.isArray(handler)) {
            for (let i = 0; i < handler.length; i++) {
                if (args.length > 0) {
                    handler[i].apply(this, args);
                } else {
                    handler[i].call(this);
                }
            }
        } else {
            if (args.length > 0) {
                handler.apply(this, args);
            } else {
                handler.call(this);
            }
        }
        return true;
    };

    EventEmitter.prototype.addListener = function(type, fn) {
        const handler = this._events.get(type); 
        if (!handler) {
            this._events.set(type, fn);
        } else if (handler && typeof handler === "function") {
            this._events.set(type, [handler, fn]); 
        } else {
            handler.push(fn); 
        }
    };

    EventEmitter.prototype.removeListener = function(type, fn) {
        const handler = this._events.get(type); 

        if (handler && typeof handler === "function") {
            this._events.delete(type, fn);
        } else {
            let position;
            for (let i = 0; i < handler.length; i++) {
                if (handler[i] === fn) {
                    position = i;
                } else {
                    position = -1;
                }
            }

            if (position !== -1) {
                handler.splice(position, 1);
                if (handler.length === 1) {
                    this._events.set(type, handler[0]);
                }
            } else {
                return this;
            }
        }
    };
```

### 实现instanceOf
```
    function instance_of(L, R) {
        var O = R.prototype; 
        L = L.__proto__; 
        while (true) {
            if (L === null) return false;
            if (O === L)
            return true;
            L = L.__proto__;
        }
    }
```

### 实现一个new
```
    function objectFactory() {
        const obj = new Object();
        const Constructor = [].shift.call(arguments);

        obj.__proto__ = Constructor.prototype;

        const ret = Constructor.apply(obj, arguments);

        return typeof ret === "object" ? ret : obj;
    }
```

### 实现一个call
```
    Function.prototype.myCall = function(context) {
        context.fn = this;
        let args = [];
        for (let i = 1, len = arguments.length; i < len; i++) {
            args.push(arguments[i]);
        }
        context.fn(...args);
        let result = context.fn(...args);
        delete context.fn;
        return result;
    };
```

### 实现一个apply
```
    Function.prototype.myapply = function(context, arr) {
        var context = Object(context) || window;
        context.fn = this;

        var result;
        if (!arr) {
            result = context.fn();
        } else {
            var args = [];
            for (var i = 0, len = arr.length; i < len; i++) {
                args.push("arr[" + i + "]");
            }
            result = eval("context.fn(" + args + ")");
        }

        delete context.fn;
        return result;
    };
```

### 实现bind
```
    if (!Function.prototype.bind) {
        Function.prototype.bind = function(oThis) {
            if (typeof this !== 'function') {
                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
            }

            var aArgs   = Array.prototype.slice.call(arguments, 1),
                fToBind = this,
                fNOP    = function() {},
                fBound  = function() {
                return fToBind.apply(this instanceof fBound
                        ? this
                        : oThis,
                        aArgs.concat(Array.prototype.slice.call(arguments)));
                };

            if (this.prototype) {
                fNOP.prototype = this.prototype; 
            }

            fBound.prototype = new fNOP();

            return fBound;
        };
    }
```

### 实现Object.create()
```
    function create(proto) {
        function F() {}
        F.prototype = proto;
        return new F();
    }
```

### 实现类的继承
```
```

### 实现rem原理
```
    function setRem(){
        let doc=document.documentElement;
        let width=doc.getBoundingClientRect().width;
        let rem=width/75;
        doc.style.fontSize=rem+'px'
    }
    addEventListener('resize',setRem)
```

### 实现一个双向数据绑定
```
```

### 实现一个简单路由
```
    class Route{
        constructor(){
            this.routes={};
            this.currentHash='';
            this.freshRoute=this.freshRoute.bind(this);
            window.addEventListener('load',this.freshRoute,false);
            window.addEventListener('hashchange',this.freshRoute,false);
        }
        storeRoute(path,cb){
            this.routes[path]=cb || function(){}
        }
        freshRoute(){
            this.currentHash=location.hash.slice(1) || '/';
            this.routes[this.currentHash]()
        }
    }
```

### 实现Promise
```
```

### 使用setTimeout实现setInterval
```
    setTimeout(function(){
        setTimeout(arguments.callee,500)
    },500)
```

### 实现JSON.parse
```
    var json = '{"name":"cxk", "age":25}';
    var obj = eval("(" + json + ")");
```

### 实现JSON.stringify
```
```

### 实现reduce方法
```
```

### 实现trim方法
```
    function trim(str){
        if(str && typeof str==='string'){
            return str.replace(/^\s+l\s+$/g/,'')
        }
    }
```

### 实现一个模板引擎 
```
    function render(template, data) {
        const reg = /\{\{(\w+)\}\}/; 
        if (reg.test(template)) { 
            const name = reg.exec(template)[1]; 
            template = template.replace(reg, data[name]); 
            return render(template, data); 
        }
        return template; 
    }
```

### 实现一个转驼峰方法camelCase
```
    function camelCase(str){
        return str.replace(/-\w/g,function(newStr){
            return newStr.slice(1).toUpperCase();
        })
    }
```

### 实现Virtual Dom && Diff
```
```


## 算法部分

### 实现冒泡排序
```
```

### 实现快速排序
```
```


## 综合部分

### 实现convert方法，将原始list转换成树形结构
```
```

### 实现一个无缝轮播图
```
```

